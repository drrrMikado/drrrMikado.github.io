<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mikado&#39;s Blog</title>
  
  
  <link href="https://mikado.drrr.app/atom.xml" rel="self"/>
  
  <link href="https://mikado.drrr.app/"/>
  <updated>2020-09-22T10:11:38.951Z</updated>
  <id>https://mikado.drrr.app/</id>
  
  <author>
    <name>Mikado</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP7-HashTable源码阅读</title>
    <link href="https://mikado.drrr.app/PHP7-HashTable/"/>
    <id>https://mikado.drrr.app/PHP7-HashTable/</id>
    <published>2020-09-22T07:36:48.000Z</published>
    <updated>2020-09-22T10:11:38.951Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="/images/PHP7-HashTable/images.png" alt="" /></p><p>PHP7数组的源码内部实现</p><p>先看下PHP7数组的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_array</span> &#123;</span></span><br><span class="line">    zend_refcounted_h gc;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ZEND_ENDIAN_LOHI_4( <span class="comment">// 解决大小端问题*</span></span><br><span class="line">                zend_uchar    flags,</span><br><span class="line">                zend_uchar    _unused,</span><br><span class="line">                zend_uchar    nIteratorsCount,</span><br><span class="line">                zend_uchar    _unused2)</span><br><span class="line">        &#125; v;</span><br><span class="line">        <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    &#125; u;</span><br><span class="line">    <span class="keyword">uint32_t</span>          nTableMask;</span><br><span class="line">    Bucket           *arData;</span><br><span class="line">    <span class="keyword">uint32_t</span>          nNumUsed;</span><br><span class="line">    <span class="keyword">uint32_t</span>          nNumOfElements;</span><br><span class="line">    <span class="keyword">uint32_t</span>          nTableSize;</span><br><span class="line">    <span class="keyword">uint32_t</span>          nInternalPointer;</span><br><span class="line">    zend_long         nNextFreeElement;</span><br><span class="line">    <span class="keyword">dtor_func_t</span>       pDestructor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以从数据结构上看到，PHP7的结构名由PHP5的HastTable修改为了zend_array。</p><a id="more"></a><p>核心数据存在在arData中，arData则是一个Bucket数组，Bucket定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Bucket</span> &#123;</span></span><br><span class="line">    zval              val; <span class="comment">// zval是可以表现PHP中所有类型的数据结构</span></span><br><span class="line">    zend_ulong        h;   <span class="comment">/* hash value (or numeric index)   */</span></span><br><span class="line">    zend_string      *key; <span class="comment">/* string key or NULL for numerics */</span></span><br><span class="line">&#125; Bucket</span><br></pre></td></tr></table></figure><p>在对比看下PHP5的Bucket：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> &#123;</span></span><br><span class="line">    ulong h;               <span class="comment">/* Used for numeric indexing */</span></span><br><span class="line">    uint nKeyLength;</span><br><span class="line">    <span class="keyword">void</span> *pData;</span><br><span class="line">    <span class="keyword">void</span> *pDataPtr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> *<span class="title">pListNext</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> *<span class="title">pListLast</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> *<span class="title">pNext</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> *<span class="title">pLast</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *arKey;</span><br><span class="line">&#125; Bucket;</span><br></pre></td></tr></table></figure><p>很直观的看到，字段少了很多。这样设计可以使内存占用从72字节，降低到了32个字节。<br />区别：</p><ul><li>Hash冲突解决方案改为bucket-&gt;zval-&gt;next，于是bucket-&gt;pNext和bucket-&gt;pLast可以去掉了</li><li>zend_array-&gt;arData是一个数组，所以不需要pListNext和pListLast来保持顺序了。遍历一个数组时，只遍历arData就可以了。</li><li>PHP7中的Bucket直接保存了zval了</li></ul><p>PHP7的packed array</p><p>全部是数字key的数组，arHash就显得没那么必要了，所以此时我们就用了一种新的数组, packed array来优化这个场景。</p><p>对于HASH_FLAG_PACKED的数组(标志在zend_array-&gt;u.flags)中，它们是只有连续数字key的数组，它们不需要Hash值来映射，所以这样的数组读取的时候，就相当于你直接访问C数组，直接根据偏移来获取zval.</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; <span class="comment">// packed array</span></span><br><span class="line">$a[<span class="string">&quot;foo&quot;</span>] = <span class="string">&quot;bar&quot;</span>; <span class="comment">// 变成了 mixed array</span></span><br><span class="line">$b[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">$b[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">$b[<span class="number">0</span>] = <span class="number">3</span>; <span class="comment">// $b mixed array</span></span><br></pre></td></tr></table></figure><p>可以看到 $b 是mixed array，竟然它的索引值是顺序的，但是它的添加顺序不是按照索引值的增长来的，这里也是为了保证PHP数组的foreach的遍历顺序是按照添加顺序来的。</p><p>对于array的类型还有以下几种：</p><ul><li><p>Static key array</p></li><li><p>Empty array</p><p>不分配arData，只有当发生实际写入时，才会分配arData。</p></li><li><p>Immutable array</p></li></ul><p>更深入理解可以阅读鸟哥的<a href="https://www.laruence.com/2020/02/25/3182.html">深入理解PHP7内核之HashTable</a>：</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/PHP7-HashTable/images.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;PHP7数组的源码内部实现&lt;/p&gt;
&lt;p&gt;先看下PHP7数组的定义：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; _&lt;span class=&quot;title&quot;&gt;zend_array&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    zend_refcounted_h gc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;union&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ZEND_ENDIAN_LOHI_4( &lt;span class=&quot;comment&quot;&gt;// 解决大小端问题*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                zend_uchar    flags,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                zend_uchar    _unused,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                zend_uchar    nIteratorsCount,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                zend_uchar    _unused2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; v;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt; flags;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; u;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt;          nTableMask;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Bucket           *arData;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt;          nNumUsed;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt;          nNumOfElements;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt;          nTableSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt;          nInternalPointer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    zend_long         nNextFreeElement;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;dtor_func_t&lt;/span&gt;       pDestructor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以从数据结构上看到，PHP7的结构名由PHP5的HastTable修改为了zend_array。&lt;/p&gt;</summary>
    
    
    
    
    <category term="PHP" scheme="https://mikado.drrr.app/tags/PHP/"/>
    
    <category term="HashTable" scheme="https://mikado.drrr.app/tags/HashTable/"/>
    
  </entry>
  
  <entry>
    <title>Bloom-Filter介绍</title>
    <link href="https://mikado.drrr.app/Bloom-Filter-Introduction/"/>
    <id>https://mikado.drrr.app/Bloom-Filter-Introduction/</id>
    <published>2020-09-22T07:33:32.000Z</published>
    <updated>2020-09-22T10:11:38.951Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="/images/Bloom-Filter-Introduction/images.png" alt="" /></p><p>布隆过滤器（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><p>如果想判断一个元素是不是在一个集合里，一般想到的是将集合中所有元素保存起来，然后通过比较确定。链表、树、散列表（又叫哈希表，Hash table）等等数据结构都是这种思路。但是随着集合中元素的增加，我们需要的存储空间越来越大。同时检索速度也越来越慢，上述三种结构的检索时间复杂度分别为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">{\displaystyle O(n),O(\log n),O(1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>。</p><a id="more"></a><p>布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。</p><p>简单来说就是：</p><ul><li>不存在就是不存在</li><li>存在是可能存在</li></ul><h2 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h2><p>相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。布隆过滤器存储空间和插入/查询时间都是常数（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">{\displaystyle O(k)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></span>）。另外，散列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。</p><p>布隆过滤器可以表示全集，其它任何数据结构都不能；</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mi>k</mi></mstyle></mrow><annotation encoding="application/x-tex">{\displaystyle k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mi>m</mi></mstyle></mrow><annotation encoding="application/x-tex">{\displaystyle m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span></span></span> 相同，使用同一组散列函数的两个布隆过滤器的交并运算可以使用位操作进行。</p><h2 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h2><p>但是布隆过滤器的缺点和优点一样明显。误算率是其中之一。随着存入的元素数量增加，误算率随之增加。但是如果元素数量太少，则使用散列表足矣。</p><p>另外，一般情况下不能从布隆过滤器中删除元素。我们很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加1, 这样删除元素时将计数器减掉就可以了。然而要保证安全地删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面。这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。</p><p>在降低误算率方面，有不少工作，使得出现了很多布隆过滤器的变种。</p><h2 id="初始化大小计算"><a class="markdownIt-Anchor" href="#初始化大小计算"></a> 初始化大小计算</h2><p>假设哈希函数以相等的概率选择每个数组位置。 如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 是数组中的位数，则在插入元素期间某个哈希函数未将某个位设置为 1 的概率为</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>−</mo><mfrac><mn>1</mn><mi>m</mi></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">1-{\frac {1}{m}}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mord">.</span></span></span></span></span></p><p>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 是散列函数的数量，并且每个散列函数之间没有显着的相关性，则该位未被任何散列函数设置为 1 的概率为</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mo fence="true">(</mo><mn>1</mn><mo>−</mo><mfrac><mn>1</mn><mi>m</mi></mfrac><mo fence="true">)</mo></mrow><mi>k</mi></msup><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\left(1-{\frac {1}{m}}\right)^{k}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.639038em;vertical-align:-0.95003em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.689008em;"><span style="top:-3.9029000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span></span></span></span></span></p><p>哈希函数的数量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 必须为正整数。 撇开此约束，对于给定的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，使假阳性概率最小的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 值为</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mfrac><mi>m</mi><mi>n</mi></mfrac><mrow><mi>l</mi><mi>n</mi><mn>2</mn></mrow></mrow><annotation encoding="application/x-tex">k=\frac{m}{n}{ln2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.7935600000000003em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">n</span><span class="mord">2</span></span></span></span></span></span></p><p>可以通过在上面的概率表达式中替换 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的最优值来计算所需的位数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>（给定 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>（插入元素的数量））和期望的假正概率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ε</span></span></span></span>（并假设使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的最优值）。 ：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mi>m</mi><mo>=</mo><mo>−</mo><mfrac><mrow><mi>n</mi><mi>ln</mi><mo>⁡</mo><mi>ε</mi></mrow><mrow><mo stretchy="false">(</mo><mi>ln</mi><mo>⁡</mo><mn>2</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mfrac></mstyle></mrow><annotation encoding="application/x-tex">{\displaystyle m=-{\frac {n\ln \varepsilon }{(\ln 2)^{2}}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.30744em;vertical-align:-0.936em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mop">ln</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">ln</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">ε</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></span></p><p>因此，每个元素的最佳位数为：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mfrac><mi>m</mi><mi>n</mi></mfrac><mo>=</mo><mo>−</mo><mfrac><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>ε</mi></mrow><mrow><mi>ln</mi><mo>⁡</mo><mn>2</mn></mrow></mfrac><mo>≈</mo><mo>−</mo><mn>1.44</mn><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>ε</mi></mstyle></mrow><annotation encoding="application/x-tex">{\displaystyle {\frac {m}{n}}=-{\frac {\log _{2}\varepsilon }{\ln 2}}\approx -1.44\log _{2}\varepsilon }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">ln</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.6769999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">ε</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">.</span><span class="mord">4</span><span class="mord">4</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">ε</span></span></span></span></span></span></p><p>具有相应数量的哈希函数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>（忽略完整性）：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><mi>k</mi><mo>=</mo><mo>−</mo><mfrac><mrow><mi>ln</mi><mo>⁡</mo><mi>ε</mi></mrow><mrow><mi>ln</mi><mo>⁡</mo><mn>2</mn></mrow></mfrac><mo>=</mo><mo>−</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>ε</mi></mstyle></mrow><annotation encoding="application/x-tex">{\displaystyle k=-{\frac {\ln \varepsilon }{\ln 2}}=-\log _{2}\varepsilon }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">ln</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">ln</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">ε</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">ε</span></span></span></span></span></span></p><p>这意味着对于给定的假正概率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ε</span></span></span></span>，布隆过滤器的长度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 与要过滤的元素的数量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 成正比，散列函数的所需数量仅取决于目标假正概率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ε</span></span></span></span>。</p><h2 id="外部链接"><a class="markdownIt-Anchor" href="#外部链接"></a> 外部链接</h2><ul><li><a href="http://www.sigma.me/2011/09/13/hash-and-bloom-filter.html">Hash和Bloom Filter介绍</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/Bloom-Filter-Introduction/images.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;布隆过滤器（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。&lt;/p&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基本概念&quot;&gt;&lt;/a&gt; 基本概念&lt;/h2&gt;
&lt;p&gt;如果想判断一个元素是不是在一个集合里，一般想到的是将集合中所有元素保存起来，然后通过比较确定。链表、树、散列表（又叫哈希表，Hash table）等等数据结构都是这种思路。但是随着集合中元素的增加，我们需要的存储空间越来越大。同时检索速度也越来越慢，上述三种结构的检索时间复杂度分别为 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mstyle scriptlevel=&quot;0&quot; displaystyle=&quot;true&quot;&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;mo separator=&quot;true&quot;&gt;,&lt;/mo&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;log&lt;/mi&gt;&lt;mo&gt;⁡&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;mo separator=&quot;true&quot;&gt;,&lt;/mo&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mstyle&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;{\displaystyle O(n),O(\log n),O(1)}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot; style=&quot;margin-right:0.02778em;&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot; style=&quot;margin-right:0.02778em;&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mop&quot;&gt;lo&lt;span style=&quot;margin-right:0.01389em;&quot;&gt;g&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot; style=&quot;margin-right:0.02778em;&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Bloom filter" scheme="https://mikado.drrr.app/tags/Bloom-filter/"/>
    
  </entry>
  
  <entry>
    <title>MapReduce论文阅读笔记</title>
    <link href="https://mikado.drrr.app/MapReduce-Paper-Notes/"/>
    <id>https://mikado.drrr.app/MapReduce-Paper-Notes/</id>
    <published>2020-09-08T09:55:01.000Z</published>
    <updated>2020-09-22T10:11:38.951Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="/images/MapReduce-Paper-Notes/images.png" alt="" /></p><h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p>MapReduce是Google提出的一个软件架构，用于大规模数据集（大于1TB）的并行运算。概念“Map”和“Reduce”，及他们的主要思想，都是从函数式编程语言借鉴的，还有从矢量编程语言借来的特性。</p><p>当前的软件实现是指定一个Map函数，用来把一组键值对映射成一组新的键值对，指定并发的Reduce函数，用来保证所有映射的键值对中的每一个共享相同的键组。</p><a id="more"></a><h2 id="编程模型"><a class="markdownIt-Anchor" href="#编程模型"></a> 编程模型</h2><p>MapReduce将计算表示为两个函数：Map和Reduce</p><p>Map：</p><p>用户编写，接收一个输入对（input pair），并产生一组中间键/值对（intermediate key/value pairs）。 MapReduce将与同一中间键 <code>I</code> 关联的所有中间值分组在一起，并将它们传递给 Reduce 函数。</p><p>Reduce：</p><p>也是用户编写，接收一个中间键 <code>I</code> 和该键下的一组值。它将这些值合并在一起以形成可能较小的一组值。通常，每个Reduce调用仅产生零或一个输出值。中间值通过迭代器提供给用户的reduce函数。这使我们能够处理太大而无法容纳在内存中的值列表。</p><h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3><p>计算大的文档集合中每个单词出现的次数，伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">map(String key, String value):</span><br><span class="line">&#x2F;&#x2F; key: document name</span><br><span class="line">&#x2F;&#x2F; value: document contents</span><br><span class="line">for each word w in value:</span><br><span class="line">EmitIntermediate(w, &quot;1&quot;);</span><br><span class="line"></span><br><span class="line">reduce(String key, Iterator values):</span><br><span class="line">&#x2F;&#x2F; key: a word</span><br><span class="line">&#x2F;&#x2F; values: a list of counts</span><br><span class="line">int result &#x3D; 0;</span><br><span class="line">for each v in values:</span><br><span class="line">result +&#x3D; ParseInt(v);</span><br><span class="line">Emit(AsString(result));</span><br></pre></td></tr></table></figure><p>关联关系大致为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map       (k1, v1)       -&gt; list(k2,v2)</span><br><span class="line">reduce    (k2, list(v2)) -&gt; list(v2)</span><br></pre></td></tr></table></figure><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><p><img data-src="/images/MapReduce-Paper-Notes/MapReduce-Execution-Overview.png" alt="" /></p><ol><li>将处理数据分为 M 个数据片段，数据大小一般在16-64MB之间</li><li>程序分为一个master，多个worker。由master执行任务的分配，有M个map任务，R个reduce任务。</li><li>分配map任务的worker，读取数据片段，解析成key/value对，并传入map函数，map函数返回的中间键值对在通过分区函数分成R个文件，文件位置将被回传到master，由master负责把这些存储位置再传送到Reduce worker。</li><li>Reduce worker接收到master发来的数据存储位置，使用RPC从Map worker所在的主机的磁盘上读取数据。读取完所有数据，通过key进行排序。</li><li>对排序后的中间数据，将每个key和它相关的中间value值集合传递到Reduce函数。Reduce函数的输出将最佳到所属分区的结果文件中。</li><li>所有的Map和Reduce任务完成后，master唤醒用户程序。</li></ol><p>MapReduce的输出存放在R个输出文件中。一般情况下，用户不需要将这R个文件合并成一个文件。这些文件可以作为另一个MapReduce任务的输入。</p><h3 id="master数据结构"><a class="markdownIt-Anchor" href="#master数据结构"></a> Master数据结构</h3><p>需要存储每一个Map和Reduce任务的状态（空闲、工作中和完成），以及Worker的标识。</p><h3 id="容错"><a class="markdownIt-Anchor" href="#容错"></a> 容错</h3><h4 id="worker-故障"><a class="markdownIt-Anchor" href="#worker-故障"></a> worker 故障</h4><p>master周期性ping每个worker。如果在一定时间内，worker没有响应，master则认为这个worker不可用，将这个worker的任务标记为空闲并重新分配给其他worker。</p><p>一个Map任务被worker A执行，但之后由于worker A不可用，master将任务重新分配给worker B，然后通知所有Reduce worker从worker B上获取任务，而不是worker A。</p><h4 id="master故障"><a class="markdownIt-Anchor" href="#master故障"></a> master故障</h4><p>简单的办法就是周期性将master状态写入磁盘，即检查点（check point）。</p><h3 id="存储位置"><a class="markdownIt-Anchor" href="#存储位置"></a> 存储位置</h3><p>输入数据存储在GFS上，GFS把每个文件按照64MB一个Block分隔，每个Block保存在多个机器（备份）。Map任务的结果放到执行Map任务的worker机器上，而Reduce任务输出文件则放到GFS文件系统上，作为下次MapReduce的输入数据。</p><h3 id="任务粒度"><a class="markdownIt-Anchor" href="#任务粒度"></a> 任务粒度</h3><p>把Map任务分为M个任务，Reduce任务分为R个任务，一般来说，M和R的数量要远远大于worker的数量，避免出现worker闲置的情况。</p><h2 id="改良"><a class="markdownIt-Anchor" href="#改良"></a> 改良</h2><h3 id="combiner函数"><a class="markdownIt-Anchor" href="#combiner函数"></a> Combiner函数</h3><p>在Map任务中会执行的函数，用于合并map任务的数据，将合并之后的数据输出。合并函数是为了减少网络传输的数据大小。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/MapReduce-Paper-Notes/images.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#介绍&quot;&gt;&lt;/a&gt; 介绍&lt;/h2&gt;
&lt;p&gt;MapReduce是Google提出的一个软件架构，用于大规模数据集（大于1TB）的并行运算。概念“Map”和“Reduce”，及他们的主要思想，都是从函数式编程语言借鉴的，还有从矢量编程语言借来的特性。&lt;/p&gt;
&lt;p&gt;当前的软件实现是指定一个Map函数，用来把一组键值对映射成一组新的键值对，指定并发的Reduce函数，用来保证所有映射的键值对中的每一个共享相同的键组。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Distributed Systems" scheme="https://mikado.drrr.app/tags/Distributed-Systems/"/>
    
    <category term="Paper" scheme="https://mikado.drrr.app/tags/Paper/"/>
    
  </entry>
  
  <entry>
    <title>Golang-Timer源码分析</title>
    <link href="https://mikado.drrr.app/Golang-Timer-Source-Code-Analysis/"/>
    <id>https://mikado.drrr.app/Golang-Timer-Source-Code-Analysis/</id>
    <published>2020-07-16T14:04:42.000Z</published>
    <updated>2020-09-22T10:11:38.951Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="/images/Golang-Timer-Source-Code-Analysis/2019-02-14-3a6d91198cfb5c37a6e4f742e2e5601d.png!q90.jpeg" alt="" /></p><p>代码环境：</p><ul><li>Golang版本：1.14.3</li><li>Server： Ubuntu Server 20.04</li></ul><h2 id="p-结构体"><a class="markdownIt-Anchor" href="#p-结构体"></a> <code>P</code> 结构体</h2><p>添加 timer 都会添加至 <code>P</code> 的结构体中，然而<code>P</code> 结构体中维护一个最小堆的 timer 数组。</p><p>代码位置：<code>runtime/runtime2.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// ......部分代码省略</span></span><br><span class="line"><span class="comment">// Lock for timers. We normally access the timers while running</span></span><br><span class="line"><span class="comment">// on this P, but the scheduler can also do it from a different P.</span></span><br><span class="line">timersLock mutex</span><br><span class="line"></span><br><span class="line"><span class="comment">// Actions to take at some time. This is used to implement the</span></span><br><span class="line"><span class="comment">// standard library&#x27;s time package.</span></span><br><span class="line"><span class="comment">// Must hold timersLock to access.</span></span><br><span class="line">timers []*timer <span class="comment">// 最小堆实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Number of timers in P&#x27;s heap.</span></span><br><span class="line"><span class="comment">// Modified using atomic instructions.</span></span><br><span class="line">numTimers <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Number of timerModifiedEarlier timers on P&#x27;s heap.</span></span><br><span class="line"><span class="comment">// This should only be modified while holding timersLock,</span></span><br><span class="line"><span class="comment">// or while the timer status is in a transient state</span></span><br><span class="line"><span class="comment">// such as timerModifying.</span></span><br><span class="line">adjustTimers <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Number of timerDeleted timers in P&#x27;s heap.</span></span><br><span class="line"><span class="comment">// Modified using atomic instructions.</span></span><br><span class="line">deletedTimers <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Race context used while executing timer functions.</span></span><br><span class="line">timerRaceCtx <span class="keyword">uintptr</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="往-p-添加-timer"><a class="markdownIt-Anchor" href="#往-p-添加-timer"></a> 往 <code>P</code> 添加 timer</h2><p>在 <code>timer.NewTimer()</code> 中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimer</span><span class="params">(d Duration)</span> *<span class="title">Timer</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> Time, <span class="number">1</span>)</span><br><span class="line">t := &amp;Timer&#123;</span><br><span class="line">C: c,</span><br><span class="line">r: runtimeTimer&#123;</span><br><span class="line">when: when(d),</span><br><span class="line">f:    sendTime,</span><br><span class="line">arg:  c,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">startTimer(&amp;t.r)</span><br><span class="line"><span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>startTime</code> 是链接到了 <code>runtime/time.go</code>，<code>runtime/time.go</code>中的 <code>startTimer</code> 实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// startTimer adds t to the timer heap.</span></span><br><span class="line"><span class="comment">//go:linkname startTimer time.startTimer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startTimer</span><span class="params">(t *timer)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racerelease(unsafe.Pointer(t))</span><br><span class="line">&#125;</span><br><span class="line">addtimer(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addtimer</code> 代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addtimer adds a timer to the current P.</span></span><br><span class="line"><span class="comment">// This should only be called with a newly created timer.</span></span><br><span class="line"><span class="comment">// That avoids the risk of changing the when field of a timer in some P&#x27;s heap,</span></span><br><span class="line"><span class="comment">// which could cause the heap to become unsorted.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addtimer</span><span class="params">(t *timer)</span></span> &#123;</span><br><span class="line"><span class="comment">// when must never be negative; otherwise runtimer will overflow</span></span><br><span class="line"><span class="comment">// during its delta calculation and never expire other runtime timers.</span></span><br><span class="line"><span class="keyword">if</span> t.when &lt; <span class="number">0</span> &#123;</span><br><span class="line">t.when = maxWhen</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> t.status != timerNoStatus &#123;</span><br><span class="line">throw(<span class="string">&quot;addtimer called with initialized timer&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">t.status = timerWaiting</span><br><span class="line"></span><br><span class="line">when := t.when</span><br><span class="line"></span><br><span class="line">pp := getg().m.p.ptr()</span><br><span class="line">lock(&amp;pp.timersLock)</span><br><span class="line">cleantimers(pp)</span><br><span class="line">doaddtimer(pp, t)</span><br><span class="line">unlock(&amp;pp.timersLock)</span><br><span class="line"></span><br><span class="line">wakeNetPoller(when)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加 timer 至 <code>P</code> 中的 timers堆中的方法是 <code>doaddtimer</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// doaddtimer adds t to the current P&#x27;s heap.</span></span><br><span class="line"><span class="comment">// The caller must have locked the timers for pp.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doaddtimer</span><span class="params">(pp *p, t *timer)</span></span> &#123;</span><br><span class="line"><span class="comment">// Timers rely on the network poller, so make sure the poller</span></span><br><span class="line"><span class="comment">// has started.</span></span><br><span class="line"><span class="keyword">if</span> netpollInited == <span class="number">0</span> &#123;</span><br><span class="line">netpollGenericInit()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> t.pp != <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;doaddtimer: P already set in timer&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">t.pp.set(pp)</span><br><span class="line">i := <span class="built_in">len</span>(pp.timers)</span><br><span class="line">pp.timers = <span class="built_in">append</span>(pp.timers, t)</span><br><span class="line">siftupTimer(pp.timers, i)</span><br><span class="line"><span class="keyword">if</span> t == pp.timers[<span class="number">0</span>] &#123;</span><br><span class="line">atomic.Store64(&amp;pp.timer0When, <span class="keyword">uint64</span>(t.when))</span><br><span class="line">&#125;</span><br><span class="line">atomic.Xadd(&amp;pp.numTimers, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始是直接 <code>append</code> 到尾部，在通过 <code>siftupTimer</code> 从下至上调整到正确的位置。</p><p><code>siftupTimer</code> 代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">siftupTimer</span><span class="params">(t []*timer, i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(t) &#123;</span><br><span class="line">badTimer()</span><br><span class="line">&#125;</span><br><span class="line">when := t[i].when</span><br><span class="line">tmp := t[i]</span><br><span class="line"><span class="keyword">for</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">p := (i - <span class="number">1</span>) / <span class="number">4</span> <span class="comment">// parent</span></span><br><span class="line"><span class="keyword">if</span> when &gt;= t[p].when &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">t[i] = t[p]</span><br><span class="line">i = p</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> tmp != t[i] &#123;</span><br><span class="line">t[i] = tmp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点看下 <code>p := (i - 1) / 4</code> ，内部维护了一个 <code>最小*四叉*堆</code> 。</p><h2 id="timer的触发"><a class="markdownIt-Anchor" href="#timer的触发"></a> Timer的触发</h2><p>触发有两种方式：</p><ol><li>从调度循环中触发</li><li>从系统监控中触发<ol><li>与 goroutine 调度完全一样，系统监控也负责 netpoller 的触发，并在必要时启动 <code>M</code> 来执行需要的 timer 或获取网络数据。</li><li>函数：<code>sysmon()</code></li></ol></li></ol><blockquote><p>调度器涉及的主要概念包括以下三个：</p><ul><li>G: Goroutine，即我们在 Go 程序中使用 go 关键字创建的执行体；</li><li>M: Machine，或 worker thread，即传统意义上进程的线程；</li><li>P: Processor，即一种人为抽象的、用于执行 Go 代码被要求局部资源。只有当 M 与一个 P 关联后才能执行 Go 代码。除非 M 发生阻塞或在进行系统调用时间过长时，没有与之关联的 P。</li></ul></blockquote><p>下面主要从调度循环中解析 timer 的触发，在每次的 goroutine 调度中，都会去检查 timers，调度代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// One round of scheduler: find a runnable goroutine and execute it.</span></span><br><span class="line"><span class="comment">// Never returns.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// ......部分代码省略</span></span><br><span class="line">checkTimers(pp, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gp *g</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 在 findrunnable 中也会调用checkTimers</span></span><br><span class="line">gp, inheritTime = findrunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>findrunnable</code> 中有个点需要注意下，<code>findrunnable</code> 部分代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findrunnable</span><span class="params">()</span> <span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">_p_ := _g_.m.p.ptr()</span><br><span class="line">(...)</span><br><span class="line"></span><br><span class="line">now, pollUntil, _ := checkTimers(_p_, <span class="number">0</span>)</span><br><span class="line">(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Poll 网络，优先级比从其他 P 中偷要高。</span></span><br><span class="line"><span class="comment">// 在我们尝试去其他 P 偷之前，这个 netpoll 只是一个优化。</span></span><br><span class="line"><span class="comment">// 如果没有 waiter 或 netpoll 中的线程已被阻塞，则可以安全地跳过它。</span></span><br><span class="line"><span class="comment">// 如果有任何类型的逻辑竞争与被阻塞的线程（例如它已经从 netpoll 返回，但尚未设置 lastpoll）</span></span><br><span class="line"><span class="comment">// 该线程无论如何都将阻塞 netpoll。</span></span><br><span class="line"><span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> list := netpoll(<span class="number">0</span>); !list.empty() &#123; <span class="comment">// 无阻塞</span></span><br><span class="line">gp := list.pop()</span><br><span class="line">injectglist(&amp;list)</span><br><span class="line">casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">(...)</span><br><span class="line"><span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从其他 P 中偷 timer</span></span><br><span class="line">ranTimer := <span class="literal">false</span></span><br><span class="line">(...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line"><span class="comment">// 随机偷</span></span><br><span class="line"><span class="keyword">for</span> enum := stealOrder.start(fastrand()); !enum.done(); enum.next() &#123;</span><br><span class="line">(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consider stealing timers from p2.</span></span><br><span class="line"><span class="comment">// This call to checkTimers is the only place where</span></span><br><span class="line"><span class="comment">// we hold a lock on a different P&#x27;s timers.</span></span><br><span class="line"><span class="comment">// Lock contention can be a problem here, so avoid</span></span><br><span class="line"><span class="comment">// grabbing the lock if p2 is running and not marked</span></span><br><span class="line"><span class="comment">// for preemption. If p2 is running and not being</span></span><br><span class="line"><span class="comment">// preempted we assume it will handle its own timers.</span></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">2</span> &amp;&amp; shouldStealTimers(p2) &#123;</span><br><span class="line">tnow, w, ran := checkTimers(p2, now)</span><br><span class="line">now = tnow</span><br><span class="line"><span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; (pollUntil == <span class="number">0</span> || w &lt; pollUntil) &#123;</span><br><span class="line">pollUntil = w</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ran &#123;</span><br><span class="line"><span class="comment">// Running the timers may have</span></span><br><span class="line"><span class="comment">// made an arbitrary number of G&#x27;s</span></span><br><span class="line"><span class="comment">// ready and added them to this P&#x27;s</span></span><br><span class="line"><span class="comment">// local run queue. That invalidates</span></span><br><span class="line"><span class="comment">// the assumption of runqsteal</span></span><br><span class="line"><span class="comment">// that is always has room to add</span></span><br><span class="line"><span class="comment">// stolen G&#x27;s. So check now if there</span></span><br><span class="line"><span class="comment">// is a local G to run.</span></span><br><span class="line"><span class="keyword">if</span> gp, inheritTime := runqget(_p_); gp != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> gp, inheritTime</span><br><span class="line">&#125;</span><br><span class="line">ranTimer = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ranTimer &#123;</span><br><span class="line"><span class="comment">// 执行完一个 timer 后可能存在已经就绪的 goroutine</span></span><br><span class="line"><span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有任何 timer</span></span><br><span class="line">(...)</span><br><span class="line">delta := <span class="keyword">int64</span>(<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> pollUntil != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// checkTimers ensures that polluntil &gt; now.</span></span><br><span class="line">delta = pollUntil - now</span><br><span class="line">&#125;</span><br><span class="line">(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// poll 网络</span></span><br><span class="line"><span class="comment">// 和上面重新找 runqueue 的逻辑类似</span></span><br><span class="line"><span class="keyword">if</span> netpollinited() &amp;&amp; (atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> || pollUntil != <span class="number">0</span>) &amp;&amp; atomic.Xchg64(&amp;sched.lastpoll, <span class="number">0</span>) != <span class="number">0</span> &#123;</span><br><span class="line">atomic.Store64(&amp;sched.pollUntil, <span class="keyword">uint64</span>(pollUntil))</span><br><span class="line">(...)</span><br><span class="line">list := netpoll(delta) <span class="comment">// block until new work is available</span></span><br><span class="line">atomic.Store64(&amp;sched.pollUntil, <span class="number">0</span>)</span><br><span class="line">atomic.Store64(&amp;sched.lastpoll, <span class="keyword">uint64</span>(nanotime()))</span><br><span class="line">(...)</span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line">_p_ = pidleget()</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"><span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">injectglist(&amp;list)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">acquirep(_p_)</span><br><span class="line"><span class="keyword">if</span> !list.empty() &#123;</span><br><span class="line">gp := list.pop()</span><br><span class="line">injectglist(&amp;list)</span><br><span class="line">casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">(...)</span><br><span class="line"><span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">(...)</span><br><span class="line"><span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> pollUntil != <span class="number">0</span> &amp;&amp; netpollinited() &#123;</span><br><span class="line">pollerPollUntil := <span class="keyword">int64</span>(atomic.Load64(&amp;sched.pollUntil))</span><br><span class="line"><span class="keyword">if</span> pollerPollUntil == <span class="number">0</span> || pollerPollUntil &gt; pollUntil &#123;</span><br><span class="line">netpollBreak()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真的什么都没找到</span></span><br><span class="line"><span class="comment">// park 当前的 m</span></span><br><span class="line">stopm()</span><br><span class="line"><span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个 <code>P</code> 因为某种原因被销毁时，还需要考虑 timer 的转移，<code>P</code> 的<code>destroy</code> 代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// destroy releases all of the resources associated with pp and</span></span><br><span class="line"><span class="comment">// transitions it to status _Pdead.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sched.lock must be held and the world must be stopped.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pp *p)</span> <span class="title">destroy</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Move all runnable goroutines to the global queue</span></span><br><span class="line"><span class="keyword">for</span> pp.runqhead != pp.runqtail &#123;</span><br><span class="line"><span class="comment">// Pop from tail of local queue</span></span><br><span class="line">pp.runqtail--</span><br><span class="line">gp := pp.runq[pp.runqtail%<span class="keyword">uint32</span>(<span class="built_in">len</span>(pp.runq))].ptr()</span><br><span class="line"><span class="comment">// Push onto head of global queue</span></span><br><span class="line">globrunqputhead(gp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> pp.runnext != <span class="number">0</span> &#123;</span><br><span class="line">globrunqputhead(pp.runnext.ptr())</span><br><span class="line">pp.runnext = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 转移 timers</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(pp.timers) &gt; <span class="number">0</span> &#123;</span><br><span class="line">plocal := getg().m.p.ptr()</span><br><span class="line"><span class="comment">// The world is stopped, but we acquire timersLock to</span></span><br><span class="line"><span class="comment">// protect against sysmon calling timeSleepUntil.</span></span><br><span class="line"><span class="comment">// This is the only case where we hold the timersLock of</span></span><br><span class="line"><span class="comment">// more than one P, so there are no deadlock concerns.</span></span><br><span class="line">lock(&amp;plocal.timersLock)</span><br><span class="line">lock(&amp;pp.timersLock)</span><br><span class="line">moveTimers(plocal, pp.timers)</span><br><span class="line">pp.timers = <span class="literal">nil</span></span><br><span class="line">pp.numTimers = <span class="number">0</span></span><br><span class="line">pp.adjustTimers = <span class="number">0</span></span><br><span class="line">pp.deletedTimers = <span class="number">0</span></span><br><span class="line">atomic.Store64(&amp;pp.timer0When, <span class="number">0</span>)</span><br><span class="line">unlock(&amp;pp.timersLock)</span><br><span class="line">unlock(&amp;plocal.timersLock)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>moveTimers</code> 代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// moveTimers moves a slice of timers to pp. The slice has been taken</span></span><br><span class="line"><span class="comment">// from a different P.</span></span><br><span class="line"><span class="comment">// This is currently called when the world is stopped, but the caller</span></span><br><span class="line"><span class="comment">// is expected to have locked the timers for pp.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">moveTimers</span><span class="params">(pp *p, timers []*timer)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, t := <span class="keyword">range</span> timers &#123;</span><br><span class="line">loop:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> s := atomic.Load(&amp;t.status); s &#123;</span><br><span class="line"><span class="keyword">case</span> timerWaiting:</span><br><span class="line">t.pp = <span class="number">0</span></span><br><span class="line">doaddtimer(pp, t)</span><br><span class="line"><span class="keyword">break</span> loop</span><br><span class="line"><span class="keyword">case</span> timerModifiedEarlier, timerModifiedLater:</span><br><span class="line"><span class="keyword">if</span> !atomic.Cas(&amp;t.status, s, timerMoving) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">t.when = t.nextwhen</span><br><span class="line">t.pp = <span class="number">0</span></span><br><span class="line">doaddtimer(pp, t)</span><br><span class="line"><span class="keyword">if</span> !atomic.Cas(&amp;t.status, timerMoving, timerWaiting) &#123;</span><br><span class="line">badTimer()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span> loop</span><br><span class="line"><span class="keyword">case</span> timerDeleted:</span><br><span class="line"><span class="keyword">if</span> !atomic.Cas(&amp;t.status, s, timerRemoved) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">t.pp = <span class="number">0</span></span><br><span class="line"><span class="comment">// We no longer need this timer in the heap.</span></span><br><span class="line"><span class="keyword">break</span> loop</span><br><span class="line"><span class="keyword">case</span> timerModifying:</span><br><span class="line"><span class="comment">// Loop until the modification is complete.</span></span><br><span class="line">osyield()</span><br><span class="line"><span class="keyword">case</span> timerNoStatus, timerRemoved:</span><br><span class="line"><span class="comment">// We should not see these status values in a timers heap.</span></span><br><span class="line">badTimer()</span><br><span class="line"><span class="keyword">case</span> timerRunning, timerRemoving, timerMoving:</span><br><span class="line"><span class="comment">// Some other P thinks it owns this timer,</span></span><br><span class="line"><span class="comment">// which should not happen.</span></span><br><span class="line">badTimer()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">badTimer()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到<code>scheduleule</code> 和 <code>findrunnable</code> 中的 <code>checkTimers</code> 代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// checkTimers runs any timers for the P that are ready.</span></span><br><span class="line"><span class="comment">// If now is not 0 it is the current time.</span></span><br><span class="line"><span class="comment">// It returns the current time or 0 if it is not known,</span></span><br><span class="line"><span class="comment">// and the time when the next timer should run or 0 if there is no next timer,</span></span><br><span class="line"><span class="comment">// and reports whether it ran any timers.</span></span><br><span class="line"><span class="comment">// If the time when the next timer should run is not 0,</span></span><br><span class="line"><span class="comment">// it is always larger than the returned time.</span></span><br><span class="line"><span class="comment">// We pass now in and out to avoid extra calls of nanotime.</span></span><br><span class="line"><span class="comment">//go:yeswritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkTimers</span><span class="params">(pp *p, now <span class="keyword">int64</span>)</span> <span class="params">(rnow, pollUntil <span class="keyword">int64</span>, ran <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// If there are no timers to adjust, and the first timer on</span></span><br><span class="line"><span class="comment">// the heap is not yet ready to run, then there is nothing to do.</span></span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;pp.adjustTimers) == <span class="number">0</span> &#123;</span><br><span class="line">next := <span class="keyword">int64</span>(atomic.Load64(&amp;pp.timer0When))</span><br><span class="line"><span class="keyword">if</span> next == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> now, <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> now == <span class="number">0</span> &#123;</span><br><span class="line">now = nanotime()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> now &lt; next &#123;</span><br><span class="line"><span class="comment">// Next timer is not ready to run.</span></span><br><span class="line"><span class="comment">// But keep going if we would clear deleted timers.</span></span><br><span class="line"><span class="comment">// This corresponds to the condition below where</span></span><br><span class="line"><span class="comment">// we decide whether to call clearDeletedTimers.</span></span><br><span class="line"><span class="keyword">if</span> pp != getg().m.p.ptr() || <span class="keyword">int</span>(atomic.Load(&amp;pp.deletedTimers)) &lt;= <span class="keyword">int</span>(atomic.Load(&amp;pp.numTimers)/<span class="number">4</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> now, next, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock(&amp;pp.timersLock)</span><br><span class="line"></span><br><span class="line">adjusttimers(pp)</span><br><span class="line"></span><br><span class="line">rnow = now</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(pp.timers) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> rnow == <span class="number">0</span> &#123;</span><br><span class="line">rnow = nanotime()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(pp.timers) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Note that runtimer may temporarily unlock</span></span><br><span class="line"><span class="comment">// pp.timersLock.</span></span><br><span class="line"><span class="keyword">if</span> tw := runtimer(pp, rnow); tw != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> tw &gt; <span class="number">0</span> &#123;</span><br><span class="line">pollUntil = tw</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">ran = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If this is the local P, and there are a lot of deleted timers,</span></span><br><span class="line"><span class="comment">// clear them out. We only do this for the local P to reduce</span></span><br><span class="line"><span class="comment">// lock contention on timersLock.</span></span><br><span class="line"><span class="keyword">if</span> pp == getg().m.p.ptr() &amp;&amp; <span class="keyword">int</span>(atomic.Load(&amp;pp.deletedTimers)) &gt; <span class="built_in">len</span>(pp.timers)/<span class="number">4</span> &#123;</span><br><span class="line">clearDeletedTimers(pp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unlock(&amp;pp.timersLock)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rnow, pollUntil, ran</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>checktimer</code> 针对timer的状态不同做出不同的处理</p><ul><li><code>timerDeleted</code> ：<ol><li>执行 <code>dodeltimer</code> 删除timer</li><li>更新timer状态（执行：<code>!atomic.Cas(&amp;t.status, timerRemoving, timerRemoved)</code> ）</li><li><code>i--</code></li></ol></li><li><code>timerModifiedEarlier</code> , <code>timerModifiedLater</code><ol><li>对比状态：<code>atomic.Cas(&amp;t.status, s, timerMoving)</code></li><li>更新timer的when属性，<code>t.when = t.nextwhen</code></li><li>执行 <code>dodeltimer</code> 删除timer</li><li>把新的 timer 放入到 <code>moved</code> 数组中，方便后面重新执行 <code>doaddtimer</code></li><li>状态等于 <code>timerModifiedEarlier</code> 时，把 <code>p</code> 的 <code>adjustTimers</code> 计数器减一，如果小于等于0，跳出循环。</li><li><code>i--</code></li></ol></li><li><code>timerNoStatus</code>, <code>timerRunning</code>, <code>timerRemoving</code>, <code>timerRemoved</code>, <code>timerMoving</code><ol><li><code>throw(&quot;timer data corruption&quot;)</code></li></ol></li><li><code>timerWaiting</code><ol><li>不做任何操作</li></ol></li><li><code>timerModifying</code><ol><li>执行 <code>osyield</code> ：修改完成后再检查</li><li><code>i--</code></li></ol></li></ul><p>最后判断 <code>moved</code> 是否为空，不为空执行重新添加timer： <code>addAdjustedTimers</code>。</p><p><code>addjusttimers</code> 执行完之后，就遍历 <code>P</code> 中的timers，对每个timer执行 <code>runtimer</code>。</p><p><code>runtimer</code> 代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtimer examines the first timer in timers. If it is ready based on now,</span></span><br><span class="line"><span class="comment">// it runs the timer and removes or updates it.</span></span><br><span class="line"><span class="comment">// Returns 0 if it ran a timer, -1 if there are no more timers, or the time</span></span><br><span class="line"><span class="comment">// when the first timer should run.</span></span><br><span class="line"><span class="comment">// The caller must have locked the timers for pp.</span></span><br><span class="line"><span class="comment">// If a timer is run, this will temporarily unlock the timers.</span></span><br><span class="line"><span class="comment">//go:systemstack</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtimer</span><span class="params">(pp *p, now <span class="keyword">int64</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">t := pp.timers[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> t.pp.ptr() != pp &#123;</span><br><span class="line">throw(<span class="string">&quot;runtimer: bad p&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> s := atomic.Load(&amp;t.status); s &#123;</span><br><span class="line"><span class="keyword">case</span> timerWaiting:</span><br><span class="line"><span class="keyword">if</span> t.when &gt; now &#123;</span><br><span class="line"><span class="comment">// Not ready to run.</span></span><br><span class="line"><span class="keyword">return</span> t.when</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !atomic.Cas(&amp;t.status, s, timerRunning) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Note that runOneTimer may temporarily unlock</span></span><br><span class="line"><span class="comment">// pp.timersLock.</span></span><br><span class="line">runOneTimer(pp, t, now)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> timerDeleted:</span><br><span class="line"><span class="keyword">if</span> !atomic.Cas(&amp;t.status, s, timerRemoving) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">dodeltimer0(pp)</span><br><span class="line"><span class="keyword">if</span> !atomic.Cas(&amp;t.status, timerRemoving, timerRemoved) &#123;</span><br><span class="line">badTimer()</span><br><span class="line">&#125;</span><br><span class="line">atomic.Xadd(&amp;pp.deletedTimers, <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(pp.timers) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> timerModifiedEarlier, timerModifiedLater:</span><br><span class="line"><span class="keyword">if</span> !atomic.Cas(&amp;t.status, s, timerMoving) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">t.when = t.nextwhen</span><br><span class="line">dodeltimer0(pp)</span><br><span class="line">doaddtimer(pp, t)</span><br><span class="line"><span class="keyword">if</span> s == timerModifiedEarlier &#123;</span><br><span class="line">atomic.Xadd(&amp;pp.adjustTimers, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !atomic.Cas(&amp;t.status, timerMoving, timerWaiting) &#123;</span><br><span class="line">badTimer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> timerModifying:</span><br><span class="line"><span class="comment">// Wait for modification to complete.</span></span><br><span class="line">osyield()</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> timerNoStatus, timerRemoved:</span><br><span class="line"><span class="comment">// Should not see a new or inactive timer on the heap.</span></span><br><span class="line">badTimer()</span><br><span class="line"><span class="keyword">case</span> timerRunning, timerRemoving, timerMoving:</span><br><span class="line"><span class="comment">// These should only be set when timers are locked,</span></span><br><span class="line"><span class="comment">// and we didn&#x27;t do it.</span></span><br><span class="line">badTimer()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">badTimer()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runtimer</code> 中也是判断 timer 的状态，如果状态等于 <code>timerWaiting</code> 并且 <code>when</code> 大于 <code>now</code> 则执行 <code>runOneTimer</code>。其他状态则跟之前的 <code>checkTimers</code>一样，维护状态。</p><p><code>runOneTimer</code> 代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runOneTimer runs a single timer.</span></span><br><span class="line"><span class="comment">// The caller must have locked the timers for pp.</span></span><br><span class="line"><span class="comment">// This will temporarily unlock the timers while running the timer function.</span></span><br><span class="line"><span class="comment">//go:systemstack</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runOneTimer</span><span class="params">(pp *p, t *timer, now <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">ppcur := getg().m.p.ptr()</span><br><span class="line"><span class="keyword">if</span> ppcur.timerRaceCtx == <span class="number">0</span> &#123;</span><br><span class="line">ppcur.timerRaceCtx = racegostart(funcPC(runtimer) + sys.PCQuantum)</span><br><span class="line">&#125;</span><br><span class="line">raceacquirectx(ppcur.timerRaceCtx, unsafe.Pointer(t))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f := t.f</span><br><span class="line">arg := t.arg</span><br><span class="line">seq := t.seq</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> t.period &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Leave in heap but adjust next time to fire.</span></span><br><span class="line">delta := t.when - now</span><br><span class="line">t.when += t.period * (<span class="number">1</span> + -delta/t.period)</span><br><span class="line">siftdownTimer(pp.timers, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> !atomic.Cas(&amp;t.status, timerRunning, timerWaiting) &#123;</span><br><span class="line">badTimer()</span><br><span class="line">&#125;</span><br><span class="line">updateTimer0When(pp)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Remove from heap.</span></span><br><span class="line">dodeltimer0(pp)</span><br><span class="line"><span class="keyword">if</span> !atomic.Cas(&amp;t.status, timerRunning, timerNoStatus) &#123;</span><br><span class="line">badTimer()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line"><span class="comment">// Temporarily use the current P&#x27;s racectx for g0.</span></span><br><span class="line">gp := getg()</span><br><span class="line"><span class="keyword">if</span> gp.racectx != <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;runOneTimer: unexpected racectx&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">gp.racectx = gp.m.p.ptr().timerRaceCtx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unlock(&amp;pp.timersLock)</span><br><span class="line"></span><br><span class="line">f(arg, seq)</span><br><span class="line"></span><br><span class="line">lock(&amp;pp.timersLock)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">gp := getg()</span><br><span class="line">gp.racectx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里流程就是：</p><ol><li>判断 <code>t.period</code> 是否大于0<ul><li>大于0则是 <code>ticker</code>，需要重新更新 <code>timer</code>，然后执行 <code>siftdownTimer</code>，从上到下构建 timers 数组。不删除timer。</li><li>小于等于0， 删除timer。</li></ul></li><li>短暂解锁 <code>timersLock</code></li><li>执行 <code>f</code> （timer 中的函数）</li><li>最后在上锁。</li></ol><p><code>siftdownTimer</code> 代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">siftdownTimer</span><span class="params">(t []*timer, i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(t)</span><br><span class="line"><span class="keyword">if</span> i &gt;= n &#123;</span><br><span class="line">badTimer()</span><br><span class="line">&#125;</span><br><span class="line">when := t[i].when</span><br><span class="line">tmp := t[i]</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">c := i*<span class="number">4</span> + <span class="number">1</span> <span class="comment">// left child</span></span><br><span class="line">c3 := c + <span class="number">2</span>  <span class="comment">// mid child</span></span><br><span class="line"><span class="keyword">if</span> c &gt;= n &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">w := t[c].when</span><br><span class="line"><span class="keyword">if</span> c+<span class="number">1</span> &lt; n &amp;&amp; t[c+<span class="number">1</span>].when &lt; w &#123;</span><br><span class="line">w = t[c+<span class="number">1</span>].when</span><br><span class="line">c++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> c3 &lt; n &#123;</span><br><span class="line">w3 := t[c3].when</span><br><span class="line"><span class="keyword">if</span> c3+<span class="number">1</span> &lt; n &amp;&amp; t[c3+<span class="number">1</span>].when &lt; w3 &#123;</span><br><span class="line">w3 = t[c3+<span class="number">1</span>].when</span><br><span class="line">c3++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> w3 &lt; w &#123;</span><br><span class="line">w = w3</span><br><span class="line">c = c3</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> w &gt;= when &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">t[i] = t[c]</span><br><span class="line">i = c</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> tmp != t[i] &#123;</span><br><span class="line">t[i] = tmp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="timer的状态转变"><a class="markdownIt-Anchor" href="#timer的状态转变"></a> timer的状态转变</h2><p>上面讲到了 timer 的状态，这里讲下 timer 的状态变化，讲 timer 的状态变化前，先列举下timer的状态有哪些：</p><ul><li><code>timerNoStatus</code><ul><li>timer还没有状态</li></ul></li><li><code>timerWaiting</code><ul><li>正在等待执行</li><li>在某个P的堆中</li></ul></li><li><code>timerRunning</code><ul><li>正在执行 timer 的函数</li><li>timer 只短暂的拥有这个状态</li></ul></li><li><code>timerDeleted</code><ul><li>timer 被删除和应该被移除（removed）</li><li>该状态下，不该执行 timer，但会存在某个 <code>p</code> 的堆中</li></ul></li><li><code>timerRemoving</code><ul><li>timer正在被移除</li><li>timer 只短暂的拥有这个状态</li></ul></li><li><code>timerRemoved</code><ul><li>timer 被停止（stopped）</li><li>不在任何 <code>p</code> 的堆中</li></ul></li><li><code>timerModifying</code><ul><li>timer 正在被修改</li><li>timer 只短暂的拥有这个状态</li></ul></li><li><code>timerModifiedEarlier</code><ul><li>timer 被修改为更早的时间</li><li>新的when值在nextwhen字段中</li><li>timer 在某个 <code>P</code> 堆中，可能在错误的位置上</li></ul></li><li><code>timerModifiedLater</code><ul><li>timer 被修改为相同或稍后的时间。</li><li>新的when值在nextwhen字段中</li><li>timer 在某个 <code>P</code> 堆中，可能在错误的位置上</li></ul></li><li><code>timerMoving</code><ul><li>timer 被修改了，并且正在移动</li><li>timer 只短暂的拥有这个状态</li></ul></li></ul><h3 id="操作timer函数的状态变化"><a class="markdownIt-Anchor" href="#操作timer函数的状态变化"></a> 操作timer函数的状态变化</h3><p>来源自代码：<code>runtime/time.go#73</code></p><ul><li><code>addtimer</code><ul><li>timerNoStatus -&gt; timerWaiting</li><li>anything else -&gt; panic: invalid value</li></ul></li><li><code>deltimer</code><ul><li>timerWaiting -&gt; timerModifying -&gt; timerDeleted</li><li>timerModifiedEarlier -&gt; timerModifying -&gt; timerDeleted</li><li>timerModifiedLater -&gt; timerModifying -&gt; timerDeleted</li><li>timerNoStatus -&gt; do nothing</li><li>timerDeleted -&gt; do nothing</li><li>timerRemoving -&gt; do nothing</li><li>timerRemoved -&gt; do nothing</li><li>timerRunning -&gt; wait until status changes</li><li>timerMoving -&gt; wait until status changes</li><li>timerModifying -&gt; wait until status changes</li></ul></li><li><code>modtimer</code><ul><li>timerWaiting -&gt; timerModifying -&gt; timerModifiedXX</li><li>timerModifiedXX -&gt; timerModifying -&gt; timerModifiedYY</li><li>timerNoStatus -&gt; timerModifying -&gt; timerWaiting</li><li>timerRemoved -&gt; timerModifying -&gt; timerWaiting</li><li>timerDeleted -&gt; timerModifying -&gt; timerModifiedXX</li><li>timerRunning -&gt; wait until status changes</li><li>timerMoving -&gt; wait until status changes</li><li>timerRemoving -&gt; wait until status changes</li><li>timerModifying -&gt; wait until status changes</li></ul></li><li><code>cleantimers</code> (looks in P’s timer heap)<ul><li>timerDeleted -&gt; timerRemoving -&gt; timerRemoved</li><li>timerModifiedXX -&gt; timerMoving -&gt; timerWaiting</li></ul></li><li><code>adjusttimers</code> (looks in P’s timer heap)<ul><li>timerDeleted -&gt; timerRemoving -&gt; timerRemoved</li><li>timerModifiedXX -&gt; timerMoving -&gt; timerWaiting</li></ul></li><li><code>runtimer</code> (looks in P’s timer heap)<ul><li>timerNoStatus -&gt; panic: uninitialized timer</li><li>timerWaiting -&gt; timerWaiting or</li><li>timerWaiting -&gt; timerRunning -&gt; timerNoStatus or</li><li>timerWaiting -&gt; timerRunning -&gt; timerWaiting</li><li>timerModifying -&gt; wait until status changes</li><li>timerModifiedXX -&gt; timerMoving -&gt; timerWaiting</li><li>timerDeleted -&gt; timerRemoving -&gt; timerRemoved</li><li>timerRunning -&gt; panic: concurrent runtimer calls</li><li>timerRemoved -&gt; panic: inconsistent timer heap</li><li>timerRemoving -&gt; panic: inconsistent timer heap</li><li>timerMoving -&gt; panic: inconsistent timer heap</li></ul></li></ul><h3 id="timer状态机"><a class="markdownIt-Anchor" href="#timer状态机"></a> timer状态机</h3><p>来源网络：</p><p><img data-src="/images/Golang-Timer-Source-Code-Analysis/Golang-Timer-State-Machine.png" alt="" /></p><p>参考文献：</p><ol><li><a href="https://changkun.de/golang/zh-cn/part2runtime/ch06sched/timer/">Go 语言原本：计时器</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/Golang-Timer-Source-Code-Analysis/2019-02-14-3a6d91198cfb5c37a6e4f742e2e5601d.png!q90.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;代码环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Golang版本：1.14.3&lt;/li&gt;
&lt;li&gt;Server： Ubuntu Server 20.04&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;p-结构体&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#p-结构体&quot;&gt;&lt;/a&gt; &lt;code&gt;P&lt;/code&gt; 结构体&lt;/h2&gt;
&lt;p&gt;添加 timer 都会添加至 &lt;code&gt;P&lt;/code&gt; 的结构体中，然而&lt;code&gt;P&lt;/code&gt; 结构体中维护一个最小堆的 timer 数组。&lt;/p&gt;
&lt;p&gt;代码位置：&lt;code&gt;runtime/runtime2.go&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; p &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// ......部分代码省略&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// Lock for timers. We normally access the timers while running&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// on this P, but the scheduler can also do it from a different P.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	timersLock mutex&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// Actions to take at some time. This is used to implement the&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// standard library&amp;#x27;s time package.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// Must hold timersLock to access.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	timers []*timer &lt;span class=&quot;comment&quot;&gt;// 最小堆实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// Number of timers in P&amp;#x27;s heap.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// Modified using atomic instructions.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	numTimers &lt;span class=&quot;keyword&quot;&gt;uint32&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// Number of timerModifiedEarlier timers on P&amp;#x27;s heap.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// This should only be modified while holding timersLock,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// or while the timer status is in a transient state&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// such as timerModifying.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	adjustTimers &lt;span class=&quot;keyword&quot;&gt;uint32&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// Number of timerDeleted timers in P&amp;#x27;s heap.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// Modified using atomic instructions.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	deletedTimers &lt;span class=&quot;keyword&quot;&gt;uint32&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// Race context used while executing timer functions.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	timerRaceCtx &lt;span class=&quot;keyword&quot;&gt;uintptr&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// ......&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Golang" scheme="https://mikado.drrr.app/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>三大缓存问题</title>
    <link href="https://mikado.drrr.app/Three-Major-Cache-Issue/"/>
    <id>https://mikado.drrr.app/Three-Major-Cache-Issue/</id>
    <published>2020-07-12T12:38:12.000Z</published>
    <updated>2020-09-22T10:11:38.951Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="/images/Three-Major-Cache-Issue/005FzdTdgy1gegf7mn8b5j31hc0u0dkw.jpg" alt="" /></p><ul><li><p>缓存一致性</p><p>缓存一致性是指业务在引入分布式缓存系统后，业务对数据的更新除了要更新存储以外还需要同时更新缓存，对两个系统进行数据更新就要先解决分布式系统中的隔离性和原子性难题。目前大多数业务在引入分布式缓存后都是通过牺牲小概率的一致性来保障业务性能，因为要在业务层严格保障数据的一致性，代价非常高，业务引入分布式缓存主要是为了解决性能问题，所以在性能和一致性面前，通常选择牺牲小概率的一致性来保障业务性能。</p></li><li><p>缓存击穿</p><p>缓存击穿是指查询请求没有在缓存层命中而将查询透传到存储 DB 的问题，当大量的请求发生缓存击穿时，将给存储 DB 带来极大的访问压力，甚至导致 DB 过载拒绝服务。</p><p>空数据查询(黑客攻击)和缓存污染（网络爬虫）是常见的引发缓存击穿的原因：</p><ul><li>空数据查询通常指攻击者伪造大量不存在的数据进行访问（比如不存在的商品信息、用户信息）。</li><li>缓存污染通常指在遍历数据等情况下冷数据把热数据驱逐出内存，导致缓存了大量冷数据而热数据被驱逐。</li></ul><p>缓存污染的场景我们目前还没有发现较好的解决方案，但是在空数据查询问题上我们可以改造业务，通过以下方式防止缓存击穿：</p><ul><li>通过 bloomfilter 记录 key 是否存在，从而避免无效 Key 的查询；</li><li>在 Redis 缓存不存在的 Key，从而避免无效 Key 的查询；</li></ul></li><li><p>缓存雪崩</p><p>缓存雪崩是指由于大量的热数据设置了相同或接近的过期时间，导致缓存在某一时刻密集失效，大量请求全部转发到 DB，或者是某个冷数据瞬间涌入大量访问，这些查询在缓存 MISS 后，并发的将请求透传到 DB，DB 瞬时压力过载从而拒绝服务。目前常见的预防缓存雪崩的解决方案，主要是通过对 key 的 TTL 时间加随机数，打散 key 的淘汰时间来尽量规避，但是不能彻底规避。</p><p><img data-src="/images/Three-Major-Cache-Issue/Cache-avalanche.png" alt="" /></p></li></ul><a id="more"></a><h2 id="传统分布式缓存方案"><a class="markdownIt-Anchor" href="#传统分布式缓存方案"></a> 传统分布式缓存方案</h2><p>原来的两层架构（应用+数据库）变成了三层架构（应用+缓存+数据库），缓存层缓存热数据，存储层复制全量数据持久化存储，存储架构的变化要求业务对数据的存取逻辑进行相应调整，这个调整是巨大的，通常需要做到三个点变化：缓存读取、缓存更新、缓存淘汰。</p><p><img data-src="/images/Three-Major-Cache-Issue/Traditional-Distributed-Cache-Solution.png" alt="" /></p><h2 id="缓存读取"><a class="markdownIt-Anchor" href="#缓存读取"></a> 缓存读取</h2><p>引入缓存层后，读数据就变得不是那么简单直接了，APP 需要先去缓存读取数据，如果缓存 MISS（数据没有被缓存），则需要从存储中读取数据，并将数据更新到缓存系统中，整个流程和代码如下所示：</p><p><img data-src="/images/Three-Major-Cache-Issue/Cache-Reading.png" alt="" /></p><h2 id="缓存更新"><a class="markdownIt-Anchor" href="#缓存更新"></a> 缓存更新</h2><p>我们把常见的缓存更新方案总结为两大类：<strong>业务层更新</strong> 和 <strong>外部组件更新</strong> ，比较常见的是通过业务更新的方案。</p><h3 id="业务层更新缓存"><a class="markdownIt-Anchor" href="#业务层更新缓存"></a> 业务层更新缓存</h3><h4 id="缓存更新的难点"><a class="markdownIt-Anchor" href="#缓存更新的难点"></a> 缓存更新的难点</h4><ul><li>数据可靠性</li></ul><p>如果要保证数据的可靠性，在业务逻辑成功之前，必须保障有一份数据落地，我们有以下两个选择：</p><ul><li>先更新成功存储，再更新缓存；</li><li>先更新成功缓存，再跟新存储，如果存储更新失败，删除缓存；</li><li>操作隔离性</li></ul><p>一条数据的更新涉及到存储和缓存两套系统，如果多个线程同时操作一条数据，并且没有方案保证多个操作之间的有序执行，就可能会发生更新顺序错乱导致数据不一致的问题。</p><p><img data-src="/images/Three-Major-Cache-Issue/Business-Layer-Update-Cache1.png" alt="" /></p><ul><li>更新原子性</li></ul><p>引入缓存后，我们需要保证缓存和存储要么同时更新成功，要么同时更新失败，否则部分更新成功就会导致缓存和存储数据不一致的问题。</p><p><img data-src="/images/Three-Major-Cache-Issue/Business-Layer-Update-Cache2.png" alt="" /></p><p>业务层缓存更新方案</p><p>我们看到大多数的常见是选择以下方案，保障数据可靠性，尽量减少数据不一致的出现，通过 TTL 超时机制在一定时间段后自动解决数据不一致现象。</p><ol><li><p>更新存储，保证数据可靠性；</p></li><li><p>更新缓存，有 2 个策略：</p><ul><li>惰性更新：删除缓存，等待下次读 MISS 再缓存（<strong>推荐</strong>）；</li><li>积极更新：将最新的值更新到缓存（<strong>不推荐</strong>）；</li></ul><p>积极更新策略，缓存数据实时性更高，但是在缓存侧带来了更多的更新操作，这会提高更新冲突导致脏数据概率。</p></li></ol><h3 id="外部组件更新缓存"><a class="markdownIt-Anchor" href="#外部组件更新缓存"></a> 外部组件更新缓存</h3><ul><li>缓存 MISS 处理方案</li></ul><p>在通过第三方组件更新的方案中，为了保障数据的一致性，避免对单条数据的并行更新，缓存的所有更新操作都需要交给同步组件，因此缓存 MISS 场景下的逻辑如下：</p><p><img data-src="/images/Three-Major-Cache-Issue/External-Component-Update-Cache1.png" alt="" /></p><ul><li><p>其他缓存更新方案</p><p>在实际的生产中，我们还会看到很多先更新缓存，然后通过第三方组件更新存储的场景，但是这个方案也会面临数据一致性和数据可靠性的挑战，虽然不推荐，但是确实还是能看到有在使用这个方案的，我们拿出来探讨下。</p><ul><li>这个场景数据可靠性低，不及先更新存储的方案，但是写入性能高，延迟低；</li><li>这个方案 APP 和第三方组件都会更新 Cache，会存在数据一致性的问题，因为很难保障两个组件更新的时序。</li></ul><p>流程图如下：</p><p><img data-src="/images/Three-Major-Cache-Issue/External-Component-Update-Cache2.png" alt="" /></p></li></ul><h2 id="缓存淘汰"><a class="markdownIt-Anchor" href="#缓存淘汰"></a> 缓存淘汰</h2><p>缓存的作用是将热点数据缓存到内存实现加速，内存的成本要远高于磁盘，因此我们通常仅仅缓存热数据在内存，冷数据需要定期的从内存淘汰，数据的淘汰通常有两种方案：</p><ul><li>主动淘汰，<strong>推荐方案</strong>，我们通过对 Key 设置 TTL 的方式来让 Key 定期淘汰，以保障冷数据不会长久的占有内存。TTL 的策略可以保证冷数据一定被淘汰，但是没有办法保障热数据始终在内存，这个我们在后面会展开；</li><li>被动淘汰，这个是保底方案，<strong>不推荐</strong>。Redis 提供了一系列的 Maxmemory 策略来对数据进行驱逐，触发的前提是内存要到达 maxmemory（内存使用率 100%），在 maxmemory 的场景下缓存的质量是不可控的，因为每次缓存一个 Key 都可能需要去淘汰一个 Key。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/Three-Major-Cache-Issue/005FzdTdgy1gegf7mn8b5j31hc0u0dkw.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;缓存一致性&lt;/p&gt;
&lt;p&gt;缓存一致性是指业务在引入分布式缓存系统后，业务对数据的更新除了要更新存储以外还需要同时更新缓存，对两个系统进行数据更新就要先解决分布式系统中的隔离性和原子性难题。目前大多数业务在引入分布式缓存后都是通过牺牲小概率的一致性来保障业务性能，因为要在业务层严格保障数据的一致性，代价非常高，业务引入分布式缓存主要是为了解决性能问题，所以在性能和一致性面前，通常选择牺牲小概率的一致性来保障业务性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缓存击穿&lt;/p&gt;
&lt;p&gt;缓存击穿是指查询请求没有在缓存层命中而将查询透传到存储 DB 的问题，当大量的请求发生缓存击穿时，将给存储 DB 带来极大的访问压力，甚至导致 DB 过载拒绝服务。&lt;/p&gt;
&lt;p&gt;空数据查询(黑客攻击)和缓存污染（网络爬虫）是常见的引发缓存击穿的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空数据查询通常指攻击者伪造大量不存在的数据进行访问（比如不存在的商品信息、用户信息）。&lt;/li&gt;
&lt;li&gt;缓存污染通常指在遍历数据等情况下冷数据把热数据驱逐出内存，导致缓存了大量冷数据而热数据被驱逐。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缓存污染的场景我们目前还没有发现较好的解决方案，但是在空数据查询问题上我们可以改造业务，通过以下方式防止缓存击穿：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过 bloomfilter 记录 key 是否存在，从而避免无效 Key 的查询；&lt;/li&gt;
&lt;li&gt;在 Redis 缓存不存在的 Key，从而避免无效 Key 的查询；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缓存雪崩&lt;/p&gt;
&lt;p&gt;缓存雪崩是指由于大量的热数据设置了相同或接近的过期时间，导致缓存在某一时刻密集失效，大量请求全部转发到 DB，或者是某个冷数据瞬间涌入大量访问，这些查询在缓存 MISS 后，并发的将请求透传到 DB，DB 瞬时压力过载从而拒绝服务。目前常见的预防缓存雪崩的解决方案，主要是通过对 key 的 TTL 时间加随机数，打散 key 的淘汰时间来尽量规避，但是不能彻底规避。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/Three-Major-Cache-Issue/Cache-avalanche.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Cache" scheme="https://mikado.drrr.app/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>Redis-Sentinel</title>
    <link href="https://mikado.drrr.app/Redis-Sentinel/"/>
    <id>https://mikado.drrr.app/Redis-Sentinel/</id>
    <published>2020-07-12T12:28:21.000Z</published>
    <updated>2020-09-22T10:11:38.951Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="/images/Redis-Sentinel/005FzdTdgy1geeswufoarj31hc0u0b29.jpg" alt="" /></p><p>Redis Sentinel为Redis提供了高可用性。实际上，这意味着使用Sentinel可以创建Redis部署（Redis deployment），该部署可以在没有人工干预的情况下抵抗某些类型的故障。</p><p>Redis Sentinel还提供其他附带任务，例如监视，通知，并充当客户端的配置提供程序。</p><ul><li><strong>监控</strong>：Sentinel会不断检查您的主（master）实例和副本（replica）实例是否按预期工作。</li><li><strong>通知</strong>：当其中一个受监视的Redis实例出了问题，Sentinel可以通过API通知系统管理员或其他计算机程序，</li><li><strong>自动故障转移</strong>：如果一个master服务器不能正常工作，Sentile 可以启动一个故障转移过程，其中一个replica被提升为主服务器，其他额外的replica被重新配置为使用新的master服务器，并且使用Redis服务器的应用程序被告知在连接时使用的新地址。</li><li><strong>配置提供者</strong>：Sentinel充当客户端服务发现的授权来源：客户端连接到Sentinel，以询问负责给定服务的当前Redis master服务器的地址。如果发生故障转移，Sentinel将报告新地址。</li></ul><a id="more"></a><h2 id="sentinel的分布式本质"><a class="markdownIt-Anchor" href="#sentinel的分布式本质"></a> Sentinel的分布式本质</h2><p>Redis Sentinel是一个分布式系统：</p><p>Sentinel本身设计为在有多个Sentinel进程协同合作的配置中运行。具有多个Sentinel进程进行协作的优点如下：</p><ol><li>当多个Sentinel同意master不在可用时，执行故障检测。这降低了误报的可能性。</li><li>即使不是所有的Sentinel进程都在工作，Sentinel仍可正常工作，从而使系统能够有强大的抗故障能力。毕竟，拥有故障转移系统本身就是一个单点故障，这没有任何乐趣。</li></ol><p>Sentinels，Redis实例（master服务器和replica）以及连接到Sentinel和 Redis的客户端的总和也是具有特定属性的大型分布式系统。</p><h2 id="运行sentinel"><a class="markdownIt-Anchor" href="#运行sentinel"></a> 运行Sentinel</h2><p>拥有独立的 <code>redis-sentinel</code> 可执行文件时：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /path/to/sentinel.conf</span><br></pre></td></tr></table></figure><p>另外可以直接使用 <code>redis-server</code> 可执行文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /path/to/sentinel.conf --sentinel</span><br></pre></td></tr></table></figure><p>两种方式都一样。</p><p>但是，在运行Sentinel时必须使用配置文件，因为系统将使用此文件来保存当前状态，以便在重启时重新加载。如果未提供配置文件或配置文件路径不可写，Sentinel只会拒绝启动。</p><p>Sentinels默认情况下会监听TCP端口26379的连接，因此，为了使Sentinels正常工作，必须打开服务器的端口26379才能从其他Sentinel实例的IP地址接收连接。否则，Sentinels无法讨论也不能就该做什么达成共识，因此将永远不会执行故障转移。</p><h2 id="部署前有关sentinel的基本知识"><a class="markdownIt-Anchor" href="#部署前有关sentinel的基本知识"></a> 部署前有关Sentinel的基本知识</h2><ol><li>一个健壮的部署（robust deployment）至少需要三个Sentinel实例。</li><li>应将三个Sentinel实例放置到被认为以独立方式失败（fail in an independent way）的计算机或虚拟机中。因此，例如不同物理服务器或虚拟机必须在不同的可用区域上部署。</li><li>由于Redis使用异步复制，Sentinel + Redis分布式系统不保证在故障期间保留已确认的写操作。然而，有一些方法可以使Sentinel在特定时刻失去写操作，同时也有一些不太安全的方法来部署它。</li><li>客户端必须开启Sentinel支持。流行的客户端库都有Sentinel支持，但不是全部。</li><li>如果不经常在开发环境中进行测试，就没有安全的HA设置;如果可以的话，在生产环境中进行测试就更好了。你可能有一个错误的配置，只有当太晚的时候（在凌晨3点，master停止工作的时候）才会变得明显。</li><li>Sentinel，Docker，或其他形式的网络地址转换或端口映射应该小心混合（mixed）：Docker执行端口重映射，破坏了其他Sentinel进程的Sentinel自动发现以及master的replica列表。</li></ol><h2 id="配置sentinel"><a class="markdownIt-Anchor" href="#配置sentinel"></a> 配置Sentinel</h2><p>配置三个Sentinel，其中端口不一样，其中一个配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1 ::1</span><br><span class="line">port 26380 # 单机上，不同Sentinel可以修改为不同的port</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile &quot;&#x2F;var&#x2F;run&#x2F;sentinel&#x2F;redis-sentinel-26380.pid&quot;</span><br><span class="line">logfile &quot;&#x2F;var&#x2F;log&#x2F;redis&#x2F;redis-sentinel-26380.log&quot;</span><br><span class="line">dir &quot;&#x2F;var&#x2F;lib&#x2F;redis&quot;</span><br><span class="line">sentinel myid 421825a687412475c44e7235823f99971edd4e2b</span><br><span class="line">protected-mode no</span><br><span class="line">sentinel deny-scripts-reconfig yes</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 60000</span><br><span class="line">sentinel auth-pass mymaster 123456 # 如果master有开启密码的话，这里需要配置</span><br></pre></td></tr></table></figure><p>replica的Redis的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Redis 5 把 slaveof 改为了 replicaof</span><br><span class="line">replicaof 127.0.0.1 16479</span><br><span class="line">masterauth 123456 # 如果master开启了auth验证</span><br></pre></td></tr></table></figure><p>其中一个Sentinel的log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">53072:X 10 Jul 2020 07:14:03.155 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">53072:X 10 Jul 2020 07:14:03.155 # Redis version&#x3D;5.0.7, bits&#x3D;64, commit&#x3D;00000000, modified&#x3D;0, pid&#x3D;53072, just started</span><br><span class="line">53072:X 10 Jul 2020 07:14:03.155 # Configuration loaded</span><br><span class="line">53073:X 10 Jul 2020 07:14:03.158 * Increased maximum number of open files to 10032 (it was originally set to 1024).</span><br><span class="line">53073:X 10 Jul 2020 07:14:03.159 * Running mode&#x3D;sentinel, port&#x3D;26380.</span><br><span class="line">53073:X 10 Jul 2020 07:14:03.164 # Sentinel ID is 421825a687412475c44e7235823f99971edd4e2b</span><br><span class="line">53073:X 10 Jul 2020 07:14:03.164 # +monitor master mymaster 127.0.0.1 16479 quorum 2</span><br><span class="line">53073:X 10 Jul 2020 07:14:03.166 * +slave slave 127.0.0.1:26479 127.0.0.1 26479 @ mymaster 127.0.0.1 16479</span><br><span class="line">53073:X 10 Jul 2020 07:14:03.172 * +slave slave 127.0.0.1:36479 127.0.0.1 36479 @ mymaster 127.0.0.1 16479</span><br><span class="line">53073:X 10 Jul 2020 07:14:31.733 * +sentinel sentinel f4c2516e7fd32e46f3efc3774d1b49ba4133e700 127.0.0.1 26381 @ mymaster 127.0.0.1 16479</span><br><span class="line">53073:X 10 Jul 2020 07:14:34.203 * +sentinel sentinel b16de2db5c788e0530998336542c11dfed2edfb5 127.0.0.1 26382 @ mymaster 127.0.0.1 16479</span><br><span class="line">53073:X 10 Jul 2020 07:19:06.736 # +sdown master mymaster 127.0.0.1 16479</span><br><span class="line">53073:X 10 Jul 2020 07:19:06.792 # +odown master mymaster 127.0.0.1 16479 #quorum 2&#x2F;2</span><br><span class="line">53073:X 10 Jul 2020 07:19:06.792 # +new-epoch 1</span><br><span class="line">53073:X 10 Jul 2020 07:19:06.792 # +try-failover master mymaster 127.0.0.1 16479</span><br><span class="line">53073:X 10 Jul 2020 07:19:06.797 # +vote-for-leader 421825a687412475c44e7235823f99971edd4e2b 1</span><br><span class="line">53073:X 10 Jul 2020 07:19:06.809 # f4c2516e7fd32e46f3efc3774d1b49ba4133e700 voted for 421825a687412475c44e7235823f99971edd4e2b 1</span><br><span class="line">53073:X 10 Jul 2020 07:19:06.810 # b16de2db5c788e0530998336542c11dfed2edfb5 voted for 421825a687412475c44e7235823f99971edd4e2b 1</span><br><span class="line">53073:X 10 Jul 2020 07:19:06.898 # +elected-leader master mymaster 127.0.0.1 16479</span><br><span class="line">53073:X 10 Jul 2020 07:19:06.898 # +failover-state-select-slave master mymaster 127.0.0.1 16479</span><br><span class="line">53073:X 10 Jul 2020 07:19:06.954 # +selected-slave slave 127.0.0.1:26479 127.0.0.1 26479 @ mymaster 127.0.0.1 16479</span><br><span class="line">53073:X 10 Jul 2020 07:19:06.954 * +failover-state-send-slaveof-noone slave 127.0.0.1:26479 127.0.0.1 26479 @ mymaster 127.0.0.1 16479</span><br><span class="line">53073:X 10 Jul 2020 07:19:07.017 * +failover-state-wait-promotion slave 127.0.0.1:26479 127.0.0.1 26479 @ mymaster 127.0.0.1 16479</span><br><span class="line">53073:X 10 Jul 2020 07:19:07.419 # +promoted-slave slave 127.0.0.1:26479 127.0.0.1 26479 @ mymaster 127.0.0.1 16479</span><br><span class="line">53073:X 10 Jul 2020 07:19:07.419 # +failover-state-reconf-slaves master mymaster 127.0.0.1 16479</span><br><span class="line">53073:X 10 Jul 2020 07:19:07.471 * +slave-reconf-sent slave 127.0.0.1:36479 127.0.0.1 36479 @ mymaster 127.0.0.1 16479</span><br><span class="line">53073:X 10 Jul 2020 07:19:07.919 # -odown master mymaster 127.0.0.1 16479</span><br><span class="line">53073:X 10 Jul 2020 07:19:08.416 * +slave-reconf-inprog slave 127.0.0.1:36479 127.0.0.1 36479 @ mymaster 127.0.0.1 16479</span><br><span class="line">53073:X 10 Jul 2020 07:19:08.416 * +slave-reconf-done slave 127.0.0.1:36479 127.0.0.1 36479 @ mymaster 127.0.0.1 16479</span><br><span class="line">53073:X 10 Jul 2020 07:19:08.492 # +failover-end master mymaster 127.0.0.1 16479</span><br><span class="line">53073:X 10 Jul 2020 07:19:08.492 # +switch-master mymaster 127.0.0.1 16479 127.0.0.1 26479</span><br><span class="line">53073:X 10 Jul 2020 07:19:08.492 * +slave slave 127.0.0.1:36479 127.0.0.1 36479 @ mymaster 127.0.0.1 26479</span><br><span class="line">53073:X 10 Jul 2020 07:19:08.492 * +slave slave 127.0.0.1:16479 127.0.0.1 16479 @ mymaster 127.0.0.1 26479</span><br></pre></td></tr></table></figure><p>从log上可以看到Sentinel的投票，更换master的流程。</p><p>Sentinel会自动更改Redis server 的配置和Sentinel的配置</p><p>更改之后Sentinel的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1 ::1</span><br><span class="line">port 26380</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile &quot;&#x2F;var&#x2F;run&#x2F;sentinel&#x2F;redis-sentinel-26380.pid&quot;</span><br><span class="line">logfile &quot;&#x2F;var&#x2F;log&#x2F;redis&#x2F;redis-sentinel-26380.log&quot;</span><br><span class="line">dir &quot;&#x2F;var&#x2F;lib&#x2F;redis&quot;</span><br><span class="line">sentinel myid 421825a687412475c44e7235823f99971edd4e2b</span><br><span class="line">protected-mode no</span><br><span class="line">sentinel deny-scripts-reconfig yes</span><br><span class="line"></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 16479 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 60000</span><br><span class="line">sentinel auth-pass mymaster 123456</span><br><span class="line">sentinel config-epoch mymaster 2</span><br><span class="line">sentinel leader-epoch mymaster 2</span><br><span class="line">sentinel known-replica mymaster 127.0.0.1 36479</span><br><span class="line"></span><br><span class="line">sentinel known-replica mymaster 127.0.0.1 26479</span><br><span class="line">sentinel known-sentinel mymaster 127.0.0.1 26382 b16de2db5c788e0530998336542c11dfed2edfb5</span><br><span class="line">sentinel known-sentinel mymaster 127.0.0.1 26381 f4c2516e7fd32e46f3efc3774d1b49ba4133e700</span><br><span class="line">sentinel current-epoch 2</span><br></pre></td></tr></table></figure><h2 id="主观下线和客观下线"><a class="markdownIt-Anchor" href="#主观下线和客观下线"></a> 主观下线和客观下线</h2><p>Redis Sentinel对于下线（down）有两个不同的概念，一个是主观下线（<code>SDOWN</code>），它是本地Sentinel判断的一个情况。<br />另一个被称为客观下线（<code>ODOWN</code>），当足够多的Sentinel（至少配置为被监视的主节点的法定人数（quorum）参数的数量）具有 <code>SDOWN</code> 条件，并使用 <code>SENTINEL is-master-down-by-addr</code> 命令从其他Sentinel那里获得反馈时，才会达到这个情况。</p><p>从Sentinel的角度来看，当它没有收到对 PING 请求的有效响应时，就会达到一个 SDOWN 条件，这个响应的秒数在配置中指定为<code>is-master-down-after-milliseconds</code>参数。</p><p>可以接受的PING回复如下:</p><ul><li>PING 回答：+PONG。</li><li>PING 回答：-LOADING 错误。</li><li>PING 回答：-MASTERDOWN 错误。</li></ul><p>任何其他答复(或根本没有答复)都被认为是无效的。但是请注意，在信息输出中将自己作为Replica声明的逻辑master服务器被认为是宕机的。</p><p>注意，SDOWN 要求在配置的整个时间间隔内不接收可接受的应答，因此，例如，如果时间间隔为30000毫秒(30秒)，并且我们每29秒就收到一个可接受的 PING 应答，则认为该实例在工作。</p><p>SDOWN 不足以触发故障转移:它只意味着一个单一的Sentinel认为Redis实例不可用。<br />要触发故障转移，必须达到ODOWN状态。</p><p>为了从 SDOWN 切换到 ODOWN，没有使用强一致性算法，而只是一种流言（gossip）：如果给定的Sentinel得到报告说，在给定的时间范围内，没有足够的Sentinel在工作，那么SDOWN将被提升为ODOWN。</p><p>为了真正启动故障转移，需要使用实际多数的更严格的授权，但是如果不达到ODOWN状态，就不能触发故障转移。</p><p>ODOWN条件仅适用于主机。对于其他类型的实例，Sentinel不需要执行操作，因此 Replica 和其他Sentinel永远不会达到ODOWN状态，而只有SDOWN可以达到。</p><h2 id="quorum法定人数"><a class="markdownIt-Anchor" href="#quorum法定人数"></a> Quorum（法定人数）</h2><p>如果quorum被配置为5，那么所有Sentinel必须就主错误条件达成一致，并且需要所有Sentinel的授权才能进行故障转移。</p><p>这意味着可以通过两种方式使用 quorum 来调优 Sentinel:</p><ul><li>如果 quorum 的值小于我们部署的大多数Sentinel的值，那么我们基本上就使Sentinel对master 节点故障更加敏感，只要有一小部分Sentinel不再能够与master通信，就会触发故障转移。</li><li>如果 quorum 值设置为大于大多数Sentinel的值，那么只有当连接良好的Sentinel数量非常大（大于大多数）且一致认为master节点处于宕机状态时，Sentinel才能够进行故障转移。</li></ul><h2 id="客户端连接问题"><a class="markdownIt-Anchor" href="#客户端连接问题"></a> 客户端连接问题</h2><ol><li>当master发生故障，Sentinel重新投票新的master，业务层代码怎么保证连接的 IP 地址是新的master的IP地址？<ol><li>VIP（虚拟IP）</li><li>Sentinel的Pub/Sub ？</li></ol></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/Redis-Sentinel/005FzdTdgy1geeswufoarj31hc0u0b29.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Redis Sentinel为Redis提供了高可用性。实际上，这意味着使用Sentinel可以创建Redis部署（Redis deployment），该部署可以在没有人工干预的情况下抵抗某些类型的故障。&lt;/p&gt;
&lt;p&gt;Redis Sentinel还提供其他附带任务，例如监视，通知，并充当客户端的配置提供程序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;监控&lt;/strong&gt;：Sentinel会不断检查您的主（master）实例和副本（replica）实例是否按预期工作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通知&lt;/strong&gt;：当其中一个受监视的Redis实例出了问题，Sentinel可以通过API通知系统管理员或其他计算机程序，&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动故障转移&lt;/strong&gt;：如果一个master服务器不能正常工作，Sentile 可以启动一个故障转移过程，其中一个replica被提升为主服务器，其他额外的replica被重新配置为使用新的master服务器，并且使用Redis服务器的应用程序被告知在连接时使用的新地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;配置提供者&lt;/strong&gt;：Sentinel充当客户端服务发现的授权来源：客户端连接到Sentinel，以询问负责给定服务的当前Redis master服务器的地址。如果发生故障转移，Sentinel将报告新地址。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Redis" scheme="https://mikado.drrr.app/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>gRPC</title>
    <link href="https://mikado.drrr.app/gRPC/"/>
    <id>https://mikado.drrr.app/gRPC/</id>
    <published>2020-07-05T07:53:17.000Z</published>
    <updated>2020-09-22T10:11:38.951Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="/images/gRPC/0072Vf1pgy1fodqpbkx8xj30xc0nke81.jpg" alt="" /></p><h2 id="什么是grpc"><a class="markdownIt-Anchor" href="#什么是grpc"></a> <strong>什么是gRPC</strong></h2><p>gRPC（gRPC Remote Procedure Calls）是由Google开发的一个现代的，开源的远程过程调用（RPC）框架，可以在任何地方运行。它使客户端和服务器应用程序可以透明地进行通信，并使构建连接的系统更加容易。</p><p>gRPC基于 HTTP/2 协议传输，使用Protocol Buffers作为接口描述语（IDL）。</p><h3 id="grpc使用场景"><a class="markdownIt-Anchor" href="#grpc使用场景"></a> gRPC使用场景</h3><ul><li>低延迟，高度可扩展的分布式系统。</li><li>开发与云服务器通信的移动客户端。</li><li>设计一个新的协议，该协议必须准确，高效且独立于语言。</li><li>分层设计以实现扩展，例如。身份验证，负载平衡，日志记录和监视等</li></ul><h2 id="什么是rpc"><a class="markdownIt-Anchor" href="#什么是rpc"></a> 什么是RPC</h2><p>在分布式计算，远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一个地址空间（通常为一个开放网络的一台计算机）的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程（无需关注细节）。RPC是一种服务器-客户端（Client/Server）模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。</p><a id="more"></a><h2 id="http2"><a class="markdownIt-Anchor" href="#http2"></a> HTTP/2</h2><p><strong>HTTP/2</strong>（超文本传输协议第2版，最初命名为<strong>HTTP 2.0</strong>），简称为<strong>h2</strong>（基于TLS/1.2或以上版本的加密连接）或<strong>h2c</strong>（非加密连接），是HTTP协议的的第二个主要版本，使用于万维网。</p><p>HTTP/2是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于<code>SPDY</code>协议。它由互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis（httpbis）工作小组进行开发。该组织于2014年12月将HTTP/2标准提议递交至IESG进行讨论，于2015年2月17日被批准。</p><h3 id="http2与http11比较"><a class="markdownIt-Anchor" href="#http2与http11比较"></a> HTTP/2与HTTP/1.1比较</h3><p>HTTP/2 相比 HTTP/1.1 的修改并不会破坏现有程序的工作，但是新的程序可以借由新特性得到更好的速度。</p><p>HTTP/2 保留了 HTTP/1.1 的大部分语义，例如请求方法、状态码乃至URI和绝大多数HTTP头部字段一致。而 HTTP/2 采用了新的方法来编码、传输 客户端&lt;——&gt;服务器 间的数据。</p><h3 id="http11与spdy的区别"><a class="markdownIt-Anchor" href="#http11与spdy的区别"></a> HTTP/1.1与SPDY的区别</h3><p>SPDY (发音为&quot;speedy&quot;) 是一个由 Google 主导的研究项目发明的HTTP替代协议。SPDY一开始主要关注降低延迟，采用了TCP通道，但是使用了不同的协议来达到此目的。其与HTTP/1.1相比，主要的改变有：</p><ul><li>实现无需先入先出的多路复用</li><li>为简化客户端和服务器开发的消息—帧机制</li><li>强制性压缩（包括HTTP头部）</li><li>优先级排序</li><li>双向通讯</li></ul><h3 id="http2与spdy的比较"><a class="markdownIt-Anchor" href="#http2与spdy的比较"></a> HTTP/2与SPDY的比较</h3><p>HTTP/2的开发基于SPDY进行跃进式改进。在诸多修改中，最显著的改进在于，HTTP/2使用了一份经过定制的压缩算法，基于霍夫曼编码，以此替代了SPDY的动态流压缩算法，以避免对协议的Oracle攻击——这一类攻击以CRIME为代表。此外，HTTP/2禁用了诸多加密包，以保证基于TLS的连接的前向安全。</p><h3 id="新特性"><a class="markdownIt-Anchor" href="#新特性"></a> 新特性</h3><p>HTTP/2 的第一版草案（对 SPDY 协议的复刻）中，新增的性能改进不仅包括HTTP/1.1中已有的多路复用，修复队头阻塞问题，允许设置设定请求优先级，还包含了一个头部压缩算法(HPACK)。此外， HTTP/2 采用了二进制而非明文来打包、传输 客户端&lt;——&gt;服务器 间的数据。</p><ul><li><p><strong>帧、消息、流和TCP连接</strong></p><p>有别于HTTP/1.1在连接中的明文请求，HTTP/2与SPDY一样，将一个TCP连接分为若干个流（Stream），每个流中可以传输若干消息（Message），每个消息由若干最小的二进制帧（Frame）组成。这也是HTTP/1.1与HTTP/2最大的区别所在。</p><p>HTTP/2中，每个用户的操作行为被分配了一个<strong>流编号</strong>(stream ID)，这意味着用户与服务端之间创建了一个TCP通道；协议将每个请求分割为二进制的控制帧与数据帧部分，以便解析。这个举措在SPDY中的实践表明，相比HTTP/1.1，新页面加载可以加快11.81% 到 47.7%</p></li><li><p><strong>HPACK 算法</strong></p><p>HPACK算法是新引入HTTP/2的一个算法，用于对HTTP头部做压缩。其原理在于：</p><ul><li>客户端与服务端根据 <a href="https://tools.ietf.org/html/rfc7541">RFC 7541</a> 的附录A，维护一份共同的静态字典（Static Table），其中包含了常见头部名及常见头部名称与值的组合的代码；</li><li>客户端和服务端根据先入先出的原则，维护一份可动态添加内容的共同动态字典（Dynamic Table）；</li><li>客户端和服务端根据 <a href="https://tools.ietf.org/html/rfc7541">RFC 7541</a> 的附录B，支持基于该静态哈夫曼码表的哈夫曼编码（Huffman Coding）。</li></ul></li><li><p><strong>服务器推送</strong></p><p>网站为了使请求数减少，通常采用对页面上的图片、脚本进行极简化处理。但是，这一举措十分不方便，也不高效，依然需要诸多HTTP链接来加载页面和页面资源。</p><p>HTTP/2引入了服务器推送，即服务端向客户端发送比客户端请求更多的数据。这允许服务器直接提供浏览器渲染页面所需资源，而无须浏览器在收到、解析页面后再提起一轮请求，节约了加载时间。</p></li></ul><h2 id="grpc调用模型"><a class="markdownIt-Anchor" href="#grpc调用模型"></a> gRPC调用模型</h2><p><img data-src="/images/gPRC/model.png" alt="" /></p><h2 id="protocal-buffers"><a class="markdownIt-Anchor" href="#protocal-buffers"></a> Protocal Buffers</h2><p>Protocol Buffers是一种序列化数据结构的协议。对于透过管道(pipeline)或存储数据进行通信的程序开发上是很有用的。这个方法包含一个接口描述语言，描述一些数据结构，并提供程序工具根据这些描述产生代码，用于将这些数据结构产生或解析数据流。</p><h3 id="google-protocol-buffer-的-encoding"><a class="markdownIt-Anchor" href="#google-protocol-buffer-的-encoding"></a> Google Protocol Buffer 的 Encoding</h3><p>Protobuf 序列化后所生成的二进制消息非常紧凑，这得益于 Protobuf 采用的非常巧妙的 Encoding 方法。</p><p>考察消息结构之前，让我首先要介绍一个叫做 Varint 的术语。</p><p>Varint 是一种紧凑的表示数字的方法。它用一个或多个字节来表示一个数字，值越小的数字使用越少的字节数。这能减少用来表示数字的字节数。</p><p>比如对于 int32 类型的数字，一般需要 4 个 byte 来表示。但是采用 Varint，对于很小的 int32 类型的数字，则可以用 1 个 byte 来表示。当然凡事都有好的也有不好的一面，采用 Varint 表示法，大的数字则需要 5 个 byte 来表示。从统计的角度来说，一般不会所有的消息中的数字都是大数，因此大多数情况下，采用 Varint 后，可以用更少的字节数来表示数字信息。下面就详细介绍一下 Varint。</p><p>Varint 中的每个 byte 的最高位 bit 有特殊的含义，如果该位为 1，表示后续的 byte 也是该数字的一部分，如果该位为 0，则结束。其他的 7 个 bit 都用来表示数字。因此小于 128 的数字都可以用一个 byte 表示。大于 128 的数字，比如 300，会用两个字节来表示：<code>1010 1100 0000 0010</code></p><p>下面演示了 Google Protocol Buffer 如何解析数字 300。注意到最终计算前将两个 byte 的位置相互交换过一次，这是因为 Google Protocol Buffer 字节序采用 <code>little-endian（小端序）</code> 的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 1010 1100 0000 0010</span><br><span class="line">→ 010 1100  000 0010</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 前后顺序对调之后</span><br><span class="line">000 0010  010 1100</span><br><span class="line">→ 000 0010 ++ 010 1100</span><br><span class="line">→ 100101100</span><br><span class="line">→ 256 + 32 + 8 + 4 &#x3D; 300</span><br></pre></td></tr></table></figure><p>消息经过序列化后会成为一个二进制数据流，该流中的数据为一系列的 Key-Value 对。如下图所示：</p><h3 id="message-buffer-图"><a class="markdownIt-Anchor" href="#message-buffer-图"></a> Message Buffer 图</h3><p><img data-src="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/image007.jpg" alt="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/image007.jpg" /></p><p>采用这种 Key-Pair 结构无需使用分隔符来分割不同的 Field。对于可选的 Field，如果消息中不存在该 field，那么在最终的 Message Buffer 中就没有该 field，这些特性都有助于节约消息本身的大小。</p><p>Key 用来标识具体的 field，在解包的时候，Protocol Buffer 据 Key 就可以知道相应的 Value 应该对应于消息中的哪一个 field。</p><p>Key 的定义如下：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>f</mi><mi>i</mi><mi>e</mi><mi>l</mi><mi>d</mi><mi mathvariant="normal">_</mi><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mo>&lt;</mo><mo>&lt;</mo><mn>3</mn><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mi>w</mi><mi>i</mi><mi>r</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>t</mi><mi>y</mi><mi>p</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">(field\_number &lt;&lt; 3) | wire\_type</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">d</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span></span></span></span></p><p>可以看到 Key 由两部分组成。第一部分是 <code>field_number</code>，第二部分为 <code>wire_type</code>。表示 Value 的传输类型。</p><p>Wire Type 可能的类型如下表所示：</p><table><thead><tr><th>Type</th><th>Meaning</th><th>Used For</th></tr></thead><tbody><tr><td>0</td><td>Varint</td><td>int32, int64, uint32, uint64, sint32, sint64, bool, enum</td></tr><tr><td>1</td><td>64-bit</td><td>fixed64, sfixed64, double</td></tr><tr><td>2</td><td>Lenth-delimited</td><td>string, bytes, embedded messages, packed repeated fields</td></tr><tr><td>3</td><td>Start group</td><td>Groups (deprecated)</td></tr><tr><td>4</td><td>End group</td><td>Groups (deprecated)</td></tr><tr><td>5</td><td>32-bit</td><td>fixed32, sfixed32, float</td></tr></tbody></table><p>Google Protocol Buffer 区别它们的主要意图也是为了减少 encoding 后的字节数。</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message Test2 &#123;</span><br><span class="line">  optional string b &#x3D; 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>b</code>的值设置为<code>testing</code>，得到字节序为：<code>12 07 74 65 73 74 69 6e 67</code></p><ul><li><code>0x12</code>是 <code>2 &lt;&lt; 3 | 2</code>，第一个2为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>i</mi><mi>e</mi><mi>l</mi><mi>d</mi><mi mathvariant="normal">_</mi><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">field\_number</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">d</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>，第二个2为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mi>i</mi><mi>r</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>t</mi><mi>y</mi><mi>p</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">wire\_type</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9695199999999999em;vertical-align:-0.31em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span></span></span></span>。</li><li><code>0x07</code>代表长度 <code>7</code>。</li><li><code>74 65 73 74 69 6e 67</code>值为<code>testing</code>。</li></ul><h2 id="grpc优缺点"><a class="markdownIt-Anchor" href="#grpc优缺点"></a> gRPC优缺点</h2><p>优点：</p><ul><li>支持多种语言（可以把proto文件看做IDL文件）</li><li>protobuf二进制消息，性能好/效率高（空间和时间效率都很不错）</li><li>proto文件生成目标代码，简单易用</li></ul><p>缺点</p><ul><li>尚未提供“服务发现”、“负载均衡”机制</li><li>gRPC调试难。HTTP/1有 curl, httpie, postman 等好工具使用，而且JSON是人类可读的 纯文本，gRPC则不同，首先它使用protobuf进行编码，其次HTTP/2是二进制协议，人类难以读懂。</li></ul><h2 id="先决条件"><a class="markdownIt-Anchor" href="#先决条件"></a> 先决条件</h2><p>生成PHP Plugin</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b v1.28.1 https://github.com/grpc/grpc</span><br><span class="line"><span class="built_in">cd</span> grpc</span><br><span class="line">git submodule update --init</span><br><span class="line">make grpc_php_plugin</span><br></pre></td></tr></table></figure><p>安装Go Plugin</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GO111MODULE=on  <span class="comment"># Enable module mode</span></span><br><span class="line">go get github.com/golang/protobuf/protoc-gen-go@v1.3</span><br></pre></td></tr></table></figure><p>安装扩展，可以使用<code>pecl</code>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pecl install grpc</span><br><span class="line">sudo pecl install protobuf</span><br></pre></td></tr></table></figure><p>安装composer</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">composer require grpc/grpc</span><br><span class="line">composer require google/protobuf</span><br></pre></td></tr></table></figure><h2 id="部署项目"><a class="markdownIt-Anchor" href="#部署项目"></a> 部署项目</h2><p>创建 gRPC 服务的第一步是在.proto 文件中定义好接口。下面的代码是一个接口的定义，它定义了一个简单的远程过程调用<code>SayHello</code>以及相应的输入和输出类型。</p><p>.proto文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package greeter;</span><br><span class="line"></span><br><span class="line">option go_package &#x3D; &quot;.;pb&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The greeting service definition.</span><br><span class="line">service Greeter &#123;</span><br><span class="line">  &#x2F;&#x2F; Sends a greeting</span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The request message containing the user&#39;s name.</span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  string name &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The response message containing the greetings</span><br><span class="line">message HelloReply &#123;</span><br><span class="line">  string message &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成代码命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=./protos --php_out=./php --grpc_out=./php  --plugin=protoc-gen-grpc=PTH/grpc_php_plugin  greeter.proto</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=./protos --go_out=plugins=grpc:./go greeter.proto</span><br></pre></td></tr></table></figure><p>编写客户端/服务端代码</p><p>客户端代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Greeter</span>\<span class="title">GreeterClient</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Greeter</span>\<span class="title">HelloReply</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Greeter</span>\<span class="title">HelloRequest</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Grpc</span>\<span class="title">UnaryCall</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">require</span> dirname(<span class="keyword">__FILE__</span>).<span class="string">&#x27;/vendor/autoload.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">include_once</span> dirname(<span class="keyword">__FILE__</span>).<span class="string">&#x27;/Greeter/GreeterClient.php&#x27;</span>;</span><br><span class="line">@<span class="keyword">include_once</span> dirname(<span class="keyword">__FILE__</span>).<span class="string">&#x27;/Greeter/HelloReply.php&#x27;</span>;</span><br><span class="line">@<span class="keyword">include_once</span> dirname(<span class="keyword">__FILE__</span>).<span class="string">&#x27;/Greeter/HelloRequest.php&#x27;</span>;</span><br><span class="line">@<span class="keyword">include_once</span> dirname(<span class="keyword">__FILE__</span>).<span class="string">&#x27;/GPBMetadata/Sample.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">$name</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $client  = <span class="keyword">new</span> GreeterClient(<span class="string">&quot;localhost:50051&quot;</span>, [</span><br><span class="line">        <span class="string">&quot;credentials&quot;</span> =&gt; Grpc\ChannelCredentials::createInsecure(),</span><br><span class="line">    ]);</span><br><span class="line">    $request = <span class="keyword">new</span> HelloRequest();</span><br><span class="line">    $request-&gt;setName($name);</span><br><span class="line">    <span class="comment">/**<span class="doctag">@var</span> UnaryCall $call */</span></span><br><span class="line">    $call = $client-&gt;SayHello($request);</span><br><span class="line">    <span class="comment">/**<span class="doctag">@var</span> HelloReply $reply */</span></span><br><span class="line">    <span class="keyword">list</span>($reply, $status) = $call-&gt;wait();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $reply-&gt;getMessage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$name = !<span class="keyword">empty</span>($argv[<span class="number">1</span>]) ? $argv[<span class="number">1</span>] : <span class="string">&#x27;PHP Client&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> greet($name).<span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>服务端代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;greeter/pb&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">pb.UnimplementedGreeterServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, in *pb.HelloRequest)</span> <span class="params">(*pb.HelloReply, error)</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Received: %v&quot;</span>, in.GetName())</span><br><span class="line"><span class="keyword">return</span> &amp;pb.HelloReply&#123;Message: <span class="string">&quot;Hello &quot;</span> + in.GetName()&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:50051&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">s := grpc.NewServer()</span><br><span class="line">pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err := s.Serve(listen); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img data-src="/images/gRPC/output.png" alt="" /></p><p>如果关心具体Go怎么实现gRPC的可以参考文档： <a href="https://www.cnblogs.com/sunsky303/p/11119300.html">https://www.cnblogs.com/sunsky303/p/11119300.html</a></p><p>代码地址：<a href="https://github.com/drrrMikado/grpc-example">https://github.com/drrrMikado/grpc-example</a></p><p>参考文献</p><ul><li><a href="https://grpc.io/docs/languages/go/quickstart/">https://grpc.io/docs/</a></li><li><a href="https://zh.wikipedia.org/wiki/HTTP/2">https://zh.wikipedia.org/wiki/HTTP/2</a></li><li><a href="https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8">https://zh.wikipedia.org/wiki/遠程過程調用</a></li><li><a href="https://zh.wikipedia.org/wiki/GRPC">https://zh.wikipedia.org/wiki/GRPC</a></li><li><a href="https://zh.wikipedia.org/wiki/Protocol_Buffers">https://zh.wikipedia.org/wiki/Protocol_Buffers</a></li><li><a href="https://developers.google.com/protocol-buffers">https://developers.google.com/protocol-buffers</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/gRPC/0072Vf1pgy1fodqpbkx8xj30xc0nke81.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是grpc&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是grpc&quot;&gt;&lt;/a&gt; &lt;strong&gt;什么是gRPC&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;gRPC（gRPC Remote Procedure Calls）是由Google开发的一个现代的，开源的远程过程调用（RPC）框架，可以在任何地方运行。它使客户端和服务器应用程序可以透明地进行通信，并使构建连接的系统更加容易。&lt;/p&gt;
&lt;p&gt;gRPC基于 HTTP/2 协议传输，使用Protocol Buffers作为接口描述语（IDL）。&lt;/p&gt;
&lt;h3 id=&quot;grpc使用场景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#grpc使用场景&quot;&gt;&lt;/a&gt; gRPC使用场景&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;低延迟，高度可扩展的分布式系统。&lt;/li&gt;
&lt;li&gt;开发与云服务器通信的移动客户端。&lt;/li&gt;
&lt;li&gt;设计一个新的协议，该协议必须准确，高效且独立于语言。&lt;/li&gt;
&lt;li&gt;分层设计以实现扩展，例如。身份验证，负载平衡，日志记录和监视等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;什么是rpc&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是rpc&quot;&gt;&lt;/a&gt; 什么是RPC&lt;/h2&gt;
&lt;p&gt;在分布式计算，远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一个地址空间（通常为一个开放网络的一台计算机）的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程（无需关注细节）。RPC是一种服务器-客户端（Client/Server）模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。&lt;/p&gt;</summary>
    
    
    
    
    <category term="gRPC" scheme="https://mikado.drrr.app/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>使用Caddy配置和部署项目</title>
    <link href="https://mikado.drrr.app/Configure-Deploy-Project-With-Caddy/"/>
    <id>https://mikado.drrr.app/Configure-Deploy-Project-With-Caddy/</id>
    <published>2020-05-22T16:13:20.000Z</published>
    <updated>2020-09-22T10:11:38.947Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="/images/Configure-Deploy-Project-With-Caddy/%E8%8A%B1%E7%81%AB10.jpg" alt="" /></p><h2 id="caddy简介"><a class="markdownIt-Anchor" href="#caddy简介"></a> Caddy简介</h2><p>Caddy服务器（或称Caddy Web）是一个开源的，使用 Golang 编写，支持 HTTP/2 的 Web 服务端。它使用 Golang 标准库提供 HTTP 功能。<br />Caddy 一个显著的特性是默认启用 HTTPS。它是第一个无需额外配置即可提供 HTTPS 特性的 Web 服务器。</p><a id="more"></a><h2 id="caddy特性"><a class="markdownIt-Anchor" href="#caddy特性"></a> Caddy特性</h2><ul><li>静态文件分发</li><li>FastCGI支持</li><li>Markdown渲染</li><li>HTTPS</li><li>自动续签证书</li><li>配置简单</li><li>…</li></ul><h2 id="安装caddy"><a class="markdownIt-Anchor" href="#安装caddy"></a> 安装Caddy</h2><blockquote><p>官网：<a href="https://caddyserver.com/">https://caddyserver.com/</a></p></blockquote><ul><li>静态二进制文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 curl</span></span><br><span class="line">curl -OL &quot;https://github.com/caddyserver/caddy/releases/latest/download/ASSET&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 wget</span></span><br><span class="line">wget &quot;https://github.com/caddyserver/caddy/releases/latest/download/ASSET&quot;</span><br></pre></td></tr></table></figure><ul><li>Docker</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull caddy</span><br></pre></td></tr></table></figure><p><a href="https://hub.docker.com/_/caddy">View on Docker Hub</a></p><ul><li>Debian, Ubuntu, Raspbian（本文采用该方法，安装到WSL1中）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;deb [trusted=yes] https://apt.fury.io/caddy/ /&quot; \</span><br><span class="line">    | sudo tee -a /etc/apt/sources.list.d/caddy-fury.list</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install caddy</span><br></pre></td></tr></table></figure><ul><li>Fedora, RedHat, CentOS</li></ul><p>Fedora or RHEL/CentOS 8:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dnf install &#x27;dnf-command(copr)&#x27;</span><br><span class="line">dnf copr enable @caddy/caddy</span><br><span class="line">dnf install caddy</span><br></pre></td></tr></table></figure><p>RHEL/CentOS 7:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install yum-plugin-copr</span><br><span class="line">yum copr enable @caddy/caddy</span><br><span class="line">yum install caddy</span><br></pre></td></tr></table></figure><ul><li>Mac OS</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install caddy</span><br></pre></td></tr></table></figure><h2 id="caddyservice配置"><a class="markdownIt-Anchor" href="#caddyservice配置"></a> Caddy.Service配置</h2><p>Caddy.service内容，使用 apt 安装会自动生成service文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;Caddy</span><br><span class="line">Documentation&#x3D;https:&#x2F;&#x2F;caddyserver.com&#x2F;docs&#x2F;</span><br><span class="line">After&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User&#x3D;caddy</span><br><span class="line">Group&#x3D;caddy</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;caddy run --environ --config &#x2F;etc&#x2F;caddy&#x2F;Caddyfile</span><br><span class="line">ExecReload&#x3D;&#x2F;usr&#x2F;bin&#x2F;caddy reload --config &#x2F;etc&#x2F;caddy&#x2F;Caddyfile</span><br><span class="line">TimeoutStopSec&#x3D;5s</span><br><span class="line">LimitNOFILE&#x3D;1048576</span><br><span class="line">LimitNPROC&#x3D;512</span><br><span class="line">PrivateTmp&#x3D;true</span><br><span class="line">ProtectSystem&#x3D;full</span><br><span class="line">AmbientCapabilities&#x3D;CAP_NET_BIND_SERVICE</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><h2 id="caddyfile文件"><a class="markdownIt-Anchor" href="#caddyfile文件"></a> Caddyfile文件</h2><p>Caddy的配置文件是json，但是由于json文件配置起来繁琐且不好管理，Caddy就推出了Caddyfile配置文件，Caddy会通过Caddyfile文件生成json配置。查看json配置内容可通过 adapt 命令查看json内容。</p><p>Caddyfile文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localhost</span><br><span class="line"></span><br><span class="line">respond &quot;Hello, world!&quot;</span><br></pre></td></tr></table></figure><p>Caddyfile转换后json字符串：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;apps&quot;</span>:&#123;<span class="attr">&quot;http&quot;</span>:&#123;<span class="attr">&quot;servers&quot;</span>:&#123;<span class="attr">&quot;srv0&quot;</span>:&#123;<span class="attr">&quot;listen&quot;</span>:[<span class="string">&quot;:443&quot;</span>],<span class="attr">&quot;routes&quot;</span>:[&#123;<span class="attr">&quot;match&quot;</span>:[&#123;<span class="attr">&quot;host&quot;</span>:[<span class="string">&quot;localhost&quot;</span>]&#125;],<span class="attr">&quot;handle&quot;</span>:[&#123;<span class="attr">&quot;handler&quot;</span>:<span class="string">&quot;subroute&quot;</span>,<span class="attr">&quot;routes&quot;</span>:[&#123;<span class="attr">&quot;handle&quot;</span>:[&#123;<span class="attr">&quot;body&quot;</span>:<span class="string">&quot;Hello, world!&quot;</span>,<span class="attr">&quot;handler&quot;</span>:<span class="string">&quot;static_response&quot;</span>&#125;]&#125;]&#125;],<span class="attr">&quot;terminal&quot;</span>:<span class="literal">true</span>&#125;]&#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>Caddyfile 配置文件大致内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">m.example.com &#123;</span><br><span class="line">    log &#123;</span><br><span class="line">        output file &#x2F;var&#x2F;log&#x2F;caddy&#x2F;mock.access.log</span><br><span class="line">    &#125;</span><br><span class="line">    encode zstd gzip</span><br><span class="line">    reverse_proxy localhost:8081 # Go项目监听的端口</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">api.example.com &#123;</span><br><span class="line">    encode zstd gzip</span><br><span class="line">    log &#123;</span><br><span class="line">        output file &#x2F;var&#x2F;log&#x2F;caddy&#x2F;mock-api.access.log</span><br><span class="line">    &#125;</span><br><span class="line">    reverse_proxy localhost:8080</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">php-fast.example.com &#123;</span><br><span class="line">    php_fastcgi 127.0.0.1:9000</span><br><span class="line">    # sock style</span><br><span class="line">    # php_fastcgi unix&#x2F;&#x2F;run&#x2F;php&#x2F;php7.4-fpm.sock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="caddy-tls"><a class="markdownIt-Anchor" href="#caddy-tls"></a> Caddy TLS</h2><p>Caddy默认使用<a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A">TLS</a>，所以在使用前需要配置证书。另外本地开发时，使用Caddy的内部，本地信任的证书</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">example.com &#123;</span><br><span class="line">    tls internal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果生产环境使用时，有命令行使用权限的话，可使用 certbot 免费生成证书，没有的话，可以使用托管服务商的证书服务。</p><h2 id="caddy与nginx简单对比"><a class="markdownIt-Anchor" href="#caddy与nginx简单对比"></a> Caddy与Nginx简单对比</h2><table><thead><tr><th style="text-align:center">对比项目</th><th style="text-align:center">Caddy</th><th style="text-align:center">Nginx</th></tr></thead><tbody><tr><td style="text-align:center">配置语法</td><td style="text-align:center">简单</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">功能</td><td style="text-align:center">慢慢增多</td><td style="text-align:center">完善，稳定</td></tr><tr><td style="text-align:center">HTTPS</td><td style="text-align:center">配置简单，且客户端自动续签，默认支持HTTPS</td><td style="text-align:center">配置繁琐，不提供自动续签证书，支持HTTPS需要配置</td></tr><tr><td style="text-align:center">处理性能</td><td style="text-align:center">性能较高</td><td style="text-align:center">性能高，系统资源占用率低</td></tr><tr><td style="text-align:center">负载均衡</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr></tbody></table><p>总结：Nginx强大而复杂，Caddy先进而简约，但在某些方面略逊一筹。由于Nginx用C语言开发，决定了在某方面性能上比用Go开发的Caddy高一些。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/Configure-Deploy-Project-With-Caddy/%E8%8A%B1%E7%81%AB10.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;caddy简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#caddy简介&quot;&gt;&lt;/a&gt; Caddy简介&lt;/h2&gt;
&lt;p&gt;Caddy服务器（或称Caddy Web）是一个开源的，使用 Golang 编写，支持 HTTP/2 的 Web 服务端。它使用 Golang 标准库提供 HTTP 功能。&lt;br /&gt;
Caddy 一个显著的特性是默认启用 HTTPS。它是第一个无需额外配置即可提供 HTTPS 特性的 Web 服务器。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Caddy" scheme="https://mikado.drrr.app/tags/Caddy/"/>
    
    <category term="Server" scheme="https://mikado.drrr.app/tags/Server/"/>
    
  </entry>
  
  <entry>
    <title>使用Travis-CI部署Hexo-Blog</title>
    <link href="https://mikado.drrr.app/Deploy-Hexo-Blog-With-Travis-CI/"/>
    <id>https://mikado.drrr.app/Deploy-Hexo-Blog-With-Travis-CI/</id>
    <published>2020-04-19T12:18:03.000Z</published>
    <updated>2020-09-22T10:11:38.947Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="/images/Deploy-Hexo-Blog-With-Travis-CI/1-44.jpg" alt="" /></p><h2 id="传统模式"><a class="markdownIt-Anchor" href="#传统模式"></a> 传统模式</h2><p>在传统模式下部署Hexo-Blog，需要在Git仓库下，执行<code>hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</code>。这步操作都是需要去手动执行。</p><a id="more"></a><h2 id="travis-ci"><a class="markdownIt-Anchor" href="#travis-ci"></a> Travis CI</h2><blockquote><p>Travis CI是在软件开发领域中的一个在线的，分布式的持续集成服务，用来构建及测试在GitHub托管的代码。这个软件的代码同时也是开源的，可以在GitHub上下载到，尽管开发者当前并不推荐在闭源项目中单独使用它。<br />它提供了多种编程语言的支持，包括Ruby、JavaScript、Java、Scala、PHP、Haskell和Erlang在内的多种语言。许多知名的开源项目使用它来在每次提交的时候进行构建测试，比如Ruby on Rails，Ruby和Node.js。</p></blockquote><p>使用Travis CI可以实现在<code>push</code>自动部署到Github Pages上。</p><h3 id="travis-ci配置"><a class="markdownIt-Anchor" href="#travis-ci配置"></a> Travis CI配置</h3><p>在项目仓库中新建<code>.travis.yml</code>文件，这个文件是Travis CI 读取的配置文件。</p><p>以Node JS为例，配置内容为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="number">13</span></span><br></pre></td></tr></table></figure><p>但在Hexo里使用CI自动部署到GitHub Pages还需要额外的配置。Pages的配置文档可以查询<a href="https://docs.travis-ci.com/user/deployment/pages/">官方文档</a>。<br />具体完整的配置内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">13</span> <span class="comment"># 使用13的版本</span></span><br><span class="line"><span class="attr">git:</span></span><br><span class="line">  <span class="attr">submodules:</span> <span class="literal">true</span> <span class="comment"># 项目中的主题是使用submodules形式，这里就要设置为true。</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span> <span class="comment"># generate static files</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">pages</span></span><br><span class="line">  <span class="attr">edge:</span> <span class="literal">true</span> <span class="comment"># 使用了dpl v2</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">drrrMikado/drrrMikado.github.io</span> <span class="comment"># 格式为 user/repo-name</span></span><br><span class="line">  <span class="attr">cleanup:</span> <span class="literal">false</span> <span class="comment"># 这是dpl v2的特性，v1使用的是skip_cleanup，v2弃用了skip_cleanup。</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">$GITHUB_TOKEN</span>  <span class="comment"># Set in the settings page of your repository, as a secure variable</span></span><br><span class="line">  <span class="attr">keep_history:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">target_branch:</span> <span class="string">master</span> <span class="comment"># 默认是gh-pages</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">local_dir:</span> <span class="string">public</span> <span class="comment"># 将目录下的public内容进行部署</span></span><br></pre></td></tr></table></figure><h2 id="使用travis-ci遇到的问题"><a class="markdownIt-Anchor" href="#使用travis-ci遇到的问题"></a> 使用Travis CI遇到的问题</h2><h3 id="npm-install报错"><a class="markdownIt-Anchor" href="#npm-install报错"></a> npm install报错</h3><p>在一开始没有指定Node版本时，<code>npm install</code>会出现报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;home&#x2F;travis&#x2F;build&#x2F;drrrMikado&#x2F;hexo-blog&#x2F;node_modules&#x2F;hexo-deployer-git&#x2F;node_modules&#x2F;eslint&#x2F;node_modules&#x2F;ajv&#x2F;node_modules&#x2F;opencollective-postinstall&#x2F;index.js:14</span><br><span class="line">    console.log(&#96;\u001b[96m\u001b[1mThank you for using $&#123;pkg.name&#125;!\u001b[96m</span><br><span class="line">                ^</span><br><span class="line">SyntaxError: Unexpected token ILLEGAL</span><br><span class="line">    at Module._compile (module.js:439:25)</span><br><span class="line">    at Object.Module._extensions..js (module.js:474:10)</span><br><span class="line">    at Module.load (module.js:356:32)</span><br><span class="line">    at Function.Module._load (module.js:312:12)</span><br><span class="line">    at Function.Module.runMain (module.js:497:10)</span><br><span class="line">    at startup (node.js:119:16)</span><br><span class="line">    at node.js:945:3</span><br></pre></td></tr></table></figure><p>在使用最新版本（13）后解决。</p><h3 id="无权限推送"><a class="markdownIt-Anchor" href="#无权限推送"></a> 无权限推送</h3><p>检查GitHub上的GITHUB_TOKEN的权限。</p><h3 id="无法推送public目录"><a class="markdownIt-Anchor" href="#无法推送public目录"></a> 无法推送Public目录</h3><p>报错信息为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;tmp&#x2F;d20200419-6633-1m1h5tm&#x2F;work</span><br><span class="line">rsync: change_dir &quot;&#x2F;home&#x2F;travis&#x2F;build&#x2F;drrrMikado&#x2F;hexo-blog&#x2F;public&quot; failed: No such file or directory (2)</span><br><span class="line">...</span><br><span class="line">Could not copy &#x2F;home&#x2F;travis&#x2F;build&#x2F;drrrMikado&#x2F;hexo-blog&#x2F;public.</span><br></pre></td></tr></table></figure><p>出现的原因是因为Travis CI会删除在构建期间创建的所有文件。<br />需要设置<code>skip_cleanup</code>为<code>true</code>，v2的话则是<code>cleanup</code>为<code>false</code>，也可能不需要设置，猜测默认值为<code>false</code>。</p><h2 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h2><p>在不使用CI的情况下，多次调整文章内容时，需要多次手动部署。而在使用CI之后，每次修改文章或配置时，只需要<code>git push</code>，之后Travis CI自动部署。<br />同时Travis CI也支持处理<code>pull request</code>的请求。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/Deploy-Hexo-Blog-With-Travis-CI/1-44.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;传统模式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#传统模式&quot;&gt;&lt;/a&gt; 传统模式&lt;/h2&gt;
&lt;p&gt;在传统模式下部署Hexo-Blog，需要在Git仓库下，执行&lt;code&gt;hexo clean &amp;amp;&amp;amp; hexo generate &amp;amp;&amp;amp; hexo deploy&lt;/code&gt;。这步操作都是需要去手动执行。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CI" scheme="https://mikado.drrr.app/tags/CI/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB中事务隔离级别和锁的关系</title>
    <link href="https://mikado.drrr.app/Transaction-Isolation-Level-AND-Locks-In-InnoDB/"/>
    <id>https://mikado.drrr.app/Transaction-Isolation-Level-AND-Locks-In-InnoDB/</id>
    <published>2020-04-18T16:38:52.000Z</published>
    <updated>2020-09-22T10:11:38.947Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="/images/Transaction-Isolation-Level-AND-Locks-In-InnoDB/1.jpg" alt="" /></p><h2 id="事务中的加锁方式"><a class="markdownIt-Anchor" href="#事务中的加锁方式"></a> 事务中的加锁方式</h2><h3 id="事务中的四种隔离级别"><a class="markdownIt-Anchor" href="#事务中的四种隔离级别"></a> 事务中的四种隔离级别</h3><table><thead><tr><th style="text-align:left">隔离级别</th><th style="text-align:left">脏读（Dirty Read）</th><th style="text-align:left">不可重复读（NonRepeatable Read）</th><th style="text-align:left">幻读（Phantom Read）</th></tr></thead><tbody><tr><td style="text-align:left">未提交读（Read Uncommitted）</td><td style="text-align:left">可能</td><td style="text-align:left">可能</td><td style="text-align:left">可能</td></tr><tr><td style="text-align:left">已提交读（Read Committed）</td><td style="text-align:left">不可能</td><td style="text-align:left">可能</td><td style="text-align:left">可能</td></tr><tr><td style="text-align:left">可重复度（Repeatable Read）</td><td style="text-align:left">不可能</td><td style="text-align:left">不可能</td><td style="text-align:left">可能</td></tr><tr><td style="text-align:left">可串行化（Serializable）</td><td style="text-align:left">不可能</td><td style="text-align:left">不可能</td><td style="text-align:left">不可能</td></tr></tbody></table><ul><li>未提交读（Read Uncommitted）：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据。数据库一般不用到该级别，任何操作不会加锁</li><li>已提交读（Read Committed）：只能允许读到已经提交的数据。Oracle等多数数据库默认该级别</li><li>可重复读（Repeatable Read）：在同一事务中的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻读</li><li>串行读（Serializable）：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</li></ul><a id="more"></a><h2 id="mysql中锁的种类"><a class="markdownIt-Anchor" href="#mysql中锁的种类"></a> MySQL中锁的种类</h2><p>MySQL中锁的种类很多，有常见的表锁和行锁，也有新加入的Metadata Lock等等，表锁是对一整张表进行锁定，虽然区分读锁和写锁，但毕竟是锁住整张表，会导致并发能力下降，一般是做ddl处理时使用。</p><p>行锁则是锁住数据行，这种加锁方式比较复杂，但是由于只锁住有限的数据，对于其他数据不加限制，所以并发能力强，MySQL一般都是用行锁来处理并发事务。</p><h2 id="read-committed已提交读"><a class="markdownIt-Anchor" href="#read-committed已提交读"></a> Read Committed（已提交读）</h2><p>在RC级别中，数据的读取都是不加锁的，但是数据的写入、修改和删除是需要加锁的。<br />表结构和数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MySQL&gt; show create table class_teacher \G;</span><br><span class="line">Table: class_teacher</span><br><span class="line">Create Table: CREATE TABLE &#96;class_teacher&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;class_name&#96; varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL,</span><br><span class="line">  &#96;teacher_id&#96; int(11) NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  KEY &#96;idx_teacher_id&#96; (&#96;teacher_id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;5 DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_unicode_ci</span><br><span class="line">1 row in set (0.02 sec)</span><br><span class="line"></span><br><span class="line">MySQL&gt; select * from class_teacher;</span><br><span class="line">+----+--------------+------------+</span><br><span class="line">| id | class_name   | teacher_id |</span><br><span class="line">+----+--------------+------------+</span><br><span class="line">|  1 | 初三一班      |          1 |</span><br><span class="line">|  3 | 初二一班      |          2 |</span><br><span class="line">|  4 | 初二二班      |          2 |</span><br><span class="line">+----+--------------+------------+</span><br></pre></td></tr></table></figure><p>由于MySQL的InnoDB默认是使用的RR级别，所以我们先要将该session开启成RC级别，并且设置binlog的模式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> committed;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> binlog_format = <span class="string">&#x27;ROW&#x27;</span>; <span class="comment">--（或者是MIXED）</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">事务A</th><th style="text-align:left">事务B</th></tr></thead><tbody><tr><td style="text-align:left">begin;</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left">update class_teacher set class_name = ‘初三二班’ where teacher_id = 1;</td><td style="text-align:left">update class_teacher set class_name=‘初三三班’ where teacher_id=1;</td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left"></td></tr></tbody></table><p>为了防止并发过程中的修改冲突，事务A中MySQL给teacher_id=1的数据行加锁，并一致不commit（释放锁），那么事务B也就一直拿不到该行锁，wait到超时。</p><p>这时我们要注意到，teacher_id是有索引的，如果是没有索引的class_name呢？<code>update class_teacher set teacher_id=3 where class_name = '初三一班'</code>; 那么MySQL会给整张表的所有数据行的加行锁。这里听起来有点不可思议，但是当sql运行的过程中，MySQL并不知道哪些数据行是 class_name = ‘初三一班’的（没有索引嘛），如果一个条件无法通过索引快速过滤，存储引擎层面就会将所有记录加锁后返回，再由MySQL Server层进行过滤。</p><p>但在实际使用过程当中，MySQL做了一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录释放锁（违背了<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4">二段锁协议的约束</a>）。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。可见即使是MySQL，为了效率也是会违反规范的。（参见《高性能MySQL》中文第三版p181）</p><p>这种情况同样适用于MySQL的默认隔离级别RR。所以对一个数据量很大的表做批量修改的时候，如果无法使用相应的索引，MySQL Server过滤数据的的时候特别慢，就会出现虽然没有修改某些行的数据，但是它们还是被锁住了的现象。</p><h2 id="repeatable-read可重复读"><a class="markdownIt-Anchor" href="#repeatable-read可重复读"></a> Repeatable Read（可重复读）</h2><p>这是MySQL中InnoDB默认的隔离级别。分为“读”和“写”两个模块来讲解。</p><h3 id="读"><a class="markdownIt-Anchor" href="#读"></a> 读</h3><p>读就是可重复读，可重复读这个概念是一事务的多个实例在并发读取数据时，会看到同样的数据行。<br />RC（不可重复读）模式下的展现</p><table><thead><tr><th style="text-align:left">事务A</th><th style="text-align:left">事务B</th></tr></thead><tbody><tr><td style="text-align:left">begin;</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left">select id,class_name,teacher_id from class_teacher where teacher_id=1;<table><tr><th>id</th><th>class_name</th><th>teacher_id</th></tr><tr><td>1</td><td>初三二班</td><td>1</td></tr><tr><td>2</td><td>初三一班</td><td>1</td></tr></table></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">update class_teacher set class_name=‘初三三班’ where id=1;<br>commit;</td></tr><tr><td style="text-align:left">select id,class_name,teacher_id from class_teacher where teacher_id=1;<table><tr><th>id</th><th>class_name</th><th>teacher_id</th></tr><tr><td>1</td><td>初三三班</td><td>1</td></tr><tr><td>2</td><td>初三一班</td><td>1</td></tr></table>读到了事务B修改的数据，和第一次查询的结果不一样，是不可重读的。</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left"></td></tr></tbody></table><p>事务B修改id=1的数据提交之后，事务A同样的查询，后一次和前一次的结果不一样，这就是不可重读（重新读取产生的结果不一样）。这就很可能带来一些问题，那么我们来看看在RR级别中MySQL的表现</p><table><thead><tr><th style="text-align:left">事务A</th><th style="text-align:left">事务B</th><th style="text-align:left">事务C</th></tr></thead><tbody><tr><td style="text-align:left">begin;</td><td style="text-align:left">begin;</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left">select id,class_name,teacher_id from class_teacher where teacher_id=1;<table><tr><th>id</th><th>class_name</th><th>teacher_id</th></tr><tr><td>1</td><td>初三二班</td><td>1</td></tr><tr><td>2</td><td>初三一班</td><td>1</td></tr></table></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">update class_teacher set class_name=‘初三三班’ where id=1;<br>commit;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">insert into class_teacher values (null,‘初三三班’,1);<br>commit;</td></tr><tr><td style="text-align:left">select id,class_name,teacher_id from class_teacher where teacher_id=1;<table><tr><th>id</th><th>class_name</th><th>teacher_id</th></tr><tr><td>1</td><td>初三二班</td><td>1</td></tr><tr><td>2</td><td>初三一班</td><td>1</td></tr></table>没有读取到事务B修改的数据，和第一次sql读取的一样，是可重复读的。没有读取到事务C新添加的数据。</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><p>当teacher_id=1时，事务A先做了一次读取，事务B中间修改了id=1的数据，并commit之后，事务A第二次读到的数据和第一次完全相同。所以说它是可重读的。</p><h4 id="不可重复读和幻读的区别"><a class="markdownIt-Anchor" href="#不可重复读和幻读的区别"></a> 不可重复读和幻读的区别</h4><p>不可重复读重点在于update和delete，而幻读的重点在于insert。</p><p>如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。</p><p>所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。</p><p>上文说的，是使用悲观锁机制来处理这两种问题，但是MySQL、ORACLE、PostgreSQL等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免这两种问题。</p><h4 id="悲观锁和乐观锁"><a class="markdownIt-Anchor" href="#悲观锁和乐观锁"></a> 悲观锁和乐观锁</h4><ul><li>悲观锁</li></ul><p>正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p><p>在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。</p><ul><li>乐观锁</li></ul><p>相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。</p><p>而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p><p>要说明的是，MVCC的实现没有固定的规范，每个数据库都会有不同的实现方式，这里讨论的是InnoDB的MVCC。</p><h4 id="mvcc在mysql的innodb中的实现"><a class="markdownIt-Anchor" href="#mvcc在mysql的innodb中的实现"></a> MVCC在MySQL的InnoDB中的实现</h4><p>在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。 在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。 在可重读RR事务隔离级别下：</p><ul><li>SELECT时，读取创建版本号&lt;=当前事务版本号，删除版本号为空或&gt;当前事务版本号。</li><li>INSERT时，保存当前事务版本号为行的创建版本号</li><li>DELETE时，保存当前事务版本号为行的删除版本号</li><li>UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行</li></ul><p>通过MVCC，虽然每行记录都需要额外的存储空间，更多的行检查工作以及一些额外的维护工作，但可以减少锁的使用，大多数读操作都不用加锁，读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，也只锁住必要行。</p><p>我们不管从数据库方面的教课书中学到，还是从网络上看到，大都是上文中事务的四种隔离级别这一模块列出的意思，RR级别是可重复读的，但无法解决幻读，而只有在Serializable级别才能解决幻读。于是我就加了一个事务C来展示效果。在事务C中添加了一条teacher_id=1的数据commit，RR级别中应该会有幻读现象，事务A在查询teacher_id=1的数据时会读到事务C新加的数据。但是测试后发现，在MySQL中是不存在这种情况的，在事务C提交后，事务A还是不会读到这条数据。可见在MySQL的RR级别中，是解决了幻读的读问题的。</p><h4 id="读与读的区别"><a class="markdownIt-Anchor" href="#读与读的区别"></a> “读”与“读”的区别</h4><p>MySQL中的读，和事务隔离级别中的读，是不一样的。</p><p>我们且看，在RR级别中，通过MVCC机制，虽然让数据变得可重复读，但我们读到的数据可能是历史数据，是不及时的数据，不是数据库当前的数据！这在一些对于数据的时效特别敏感的业务中，就很可能出问题。</p><p>对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)，而读取数据库当前版本数据的方式，叫当前读 (current read)。很显然，在MVCC中：</p><ul><li><p>快照读：就是select</p><ul><li>select * from table ….;</li></ul></li><li><p>当前读：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁。</p><ul><li>select * from table where ? lock in share mode;</li><li>select * from table where ? for update;</li><li>insert;</li><li>update ;</li><li>delete;</li></ul></li></ul><p>事务的隔离级别实际上都是定义了当前读的级别，MySQL为了减少锁处理（包括等待其它锁）的时间，提升并发能力，引入了快照读的概念，使得select不用加锁。而update、insert这些“当前读”，就需要另外的模块来解决了。</p><h3 id="写当前读"><a class="markdownIt-Anchor" href="#写当前读"></a> 写（“当前读”）</h3><p>事务的隔离级别中虽然只定义了读数据的要求，实际上也可以说是写数据的要求。上文的“读”，实际是讲快照读；而这里说的“写”就是当前读。</p><p>为了解决当前读中的幻读问题，MySQL事务使用了Next-Key锁。</p><h4 id="next-key锁"><a class="markdownIt-Anchor" href="#next-key锁"></a> Next-Key锁</h4><p>Next-Key锁是行锁与GAP（间隙锁）的合并，行锁上文已经介绍了，接下来说下GAP间隙锁。</p><p>行锁可以防止不同事务版本的数据修改提交时造成数据冲突的情况。但如何避免别的事务插入数据就成了问题。我们可以看看RR级别和RC级别的对比</p><p>RC级别：</p><table><thead><tr><th style="text-align:left">事务A</th><th style="text-align:left">事务B</th></tr></thead><tbody><tr><td style="text-align:left">begin;</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left">select id,class_name,teacher_id from class_teacher where teacher_id=30;<table><tr><th>id</th><th>class_name</th><th>teacher_id</th></tr><tr><td>2</td><td>初三二班</td><td>30</td></tr></table></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">update class_teacher set class_name=‘初三四班’ where teacher_id=30;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">insert into class_teacher values (null,‘初三二班’,30);<br>commit;</td></tr><tr><td style="text-align:left">select id,class_name,teacher_id from class_teacher where teacher_id=30;<table><tr><th>id</th><th>class_name</th><th>teacher_id</th></tr><tr><td>2</td><td>初三四班</td><td>30</td></tr><tr><td>10</td><td>初三二班</td><td>30</td></tr></table></td><td style="text-align:left"></td></tr></tbody></table><p>RR级别：</p><table><thead><tr><th style="text-align:left">事务A</th><th style="text-align:left">事务B</th></tr></thead><tbody><tr><td style="text-align:left">begin;</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left">select id,class_name,teacher_id from class_teacher where teacher_id=30;<table><tr><th>id</th><th>class_name</th><th>teacher_id</th></tr><tr><td>2</td><td>初三二班</td><td>30</td></tr></table></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">update class_teacher set class_name=‘初三四班’ where teacher_id=30;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">insert into class_teacher values (null,‘初三二班’,30);<br>waiting…</td></tr><tr><td style="text-align:left">select id,class_name,teacher_id from class_teacher where teacher_id=30;<table><tr><th>id</th><th>class_name</th><th>teacher_id</th></tr><tr><td>2</td><td>初三二班</td><td>30</td></tr></table></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">事务A commit后，事务B的insert执行。</td></tr></tbody></table><p>通过对比我们可以发现，在RC级别中，事务A修改了所有teacher_id=30的数据，但是当事务Binsert进新数据后，事务A发现莫名其妙多了一行teacher_id=30的数据，而且没有被之前的update语句所修改，这就是“当前读”的幻读。</p><p>RR级别中，事务A在update后加锁，事务B无法插入新数据，这样事务A在update前后读的数据保持一致，避免了幻读。这个锁，就是Gap锁。</p><p>MySQL是这么实现的：</p><p>在class_teacher这张表中，teacher_id是个索引，那么它就会维护一套B+树的数据关系，为了简化，我们用链表结构来表达（实际上是个树形结构，但原理相同）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">                                               +----------+</span><br><span class="line">                                               | GAP Lock |</span><br><span class="line">                                               +-+----+---+</span><br><span class="line">                                                 |    |</span><br><span class="line">                                                 |    |</span><br><span class="line">                                   +-------------+    |</span><br><span class="line">                                   |                  |</span><br><span class="line">                                   v                  v</span><br><span class="line">+------------------------+-----+---+----+------+------+-----------------+</span><br><span class="line">| (negative infinity, 5] |  5  | (5,30] |  30  | (30,positive infinity) |</span><br><span class="line">+------------------------+---+-+--------+-+--+-+------------------------+</span><br><span class="line">                             ^            ^  ^</span><br><span class="line">                             |            |  |</span><br><span class="line">                             +------+-----+  +----------+</span><br><span class="line">                                    |                   |</span><br><span class="line">                                    |                   |</span><br><span class="line">                               +----+-----+          +--+-------+</span><br><span class="line">                               | Data Row |          | Row Lock |</span><br><span class="line">                               +----------+          +----------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如图所示，InnoDB使用的是聚集索引，teacher_id身为二级索引，就要维护一个索引字段和主键id的树状结构（这里用链表形式表现），并保持顺序排列。</p><p>Innodb将这段数据分成几个个区间</p><ul><li>(negative infinity, 5],</li><li>(5,30],</li><li>(30,positive infinity)；</li></ul><p><code>update class_teacher set class_name=‘初三四班’ where teacher_id=30;</code> 不仅用行锁，锁住了相应的数据行；同时也在两边的区间，(5,30] 和 (30，positive infinity)，都加入了GAP锁。这样事务B就无法在这个两个区间insert进新数据。</p><p>受限于这种实现方式，Innodb很多时候会锁住不需要锁的区间。如下所示：</p><table><thead><tr><th style="text-align:left">事务A</th><th style="text-align:left">事务B</th><th style="text-align:left">事务C</th></tr></thead><tbody><tr><td style="text-align:left">begin;</td><td style="text-align:left">begin;</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left">select id,class_name,teacher_id from class_teacher; <table><tr><th>id</th><th>class_name</th><th>teacher_id</th></tr><tr><td>1</td><td>初三一班</td><td>5</td></tr><tr><td>2</td><td>初三二班</td><td>30</td></tr></table></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">update class_teacher set class_name=‘初一一班’ where teacher_id=20;</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">insert into class_teacher values (null,‘初三五班’,10);<br>waiting…</td><td style="text-align:left">insert into class_teacher values (null,‘初三五班’,40);</td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">事务A commit之后，这条语句才插入成功</td><td style="text-align:left">commit;</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">commit;</td><td style="text-align:left"></td></tr></tbody></table><p>update的teacher_id=20是在(5，30]区间，即使没有修改任何数据，Innodb也会在这个区间加gap锁，而其它区间不会影响，事务C正常插入。</p><p>如果使用的是没有索引的字段，比如update class_teacher set teacher_id=7 where class_name=‘初三八班（即使没有匹配到任何数据）’,那么会给全表加入gap锁。同时，它不能像上文中行锁一样经过MySQL Server过滤自动解除不满足条件的锁，因为没有索引，则这些字段也就没有排序，也就没有区间。除非该事务提交，否则其它事务无法插入任何数据。</p><p>行锁防止别的事务修改或删除，GAP锁防止别的事务新增，行锁和GAP锁结合形成的的Next-Key锁共同解决了RR级别在写数据时的幻读问题。</p><h2 id="serializable"><a class="markdownIt-Anchor" href="#serializable"></a> Serializable</h2><p>这个级别很简单，读加共享锁，写加排他锁，读写互斥。使用的悲观锁的理论，实现简单，数据更加安全，但是并发能力非常差。如果你的业务并发的特别少或者没有并发，同时又要求数据及时可靠的话，可以使用这种模式。</p><p>在Serializable这个级别，select 还是会加锁的！</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">https://tech.meituan.com/2014/08/20/innodb-lock.html</a></li><li><a href="http://dev.mysql.com/doc/">MySQL参考手册</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/Transaction-Isolation-Level-AND-Locks-In-InnoDB/1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;事务中的加锁方式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#事务中的加锁方式&quot;&gt;&lt;/a&gt; 事务中的加锁方式&lt;/h2&gt;
&lt;h3 id=&quot;事务中的四种隔离级别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#事务中的四种隔离级别&quot;&gt;&lt;/a&gt; 事务中的四种隔离级别&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;隔离级别&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;脏读（Dirty Read）&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;不可重复读（NonRepeatable Read）&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;幻读（Phantom Read）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;未提交读（Read Uncommitted）&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;可能&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;可能&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;可能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;已提交读（Read Committed）&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;不可能&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;可能&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;可能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;可重复度（Repeatable Read）&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;不可能&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;不可能&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;可能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;可串行化（Serializable）&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;不可能&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;不可能&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;不可能&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;未提交读（Read Uncommitted）：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据。数据库一般不用到该级别，任何操作不会加锁&lt;/li&gt;
&lt;li&gt;已提交读（Read Committed）：只能允许读到已经提交的数据。Oracle等多数数据库默认该级别&lt;/li&gt;
&lt;li&gt;可重复读（Repeatable Read）：在同一事务中的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻读&lt;/li&gt;
&lt;li&gt;串行读（Serializable）：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="InnoDB" scheme="https://mikado.drrr.app/tags/InnoDB/"/>
    
    <category term="MySQL" scheme="https://mikado.drrr.app/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>译：InnoDB索引</title>
    <link href="https://mikado.drrr.app/InnoDB-Indexes-Translation/"/>
    <id>https://mikado.drrr.app/InnoDB-Indexes-Translation/</id>
    <published>2020-04-13T06:30:50.000Z</published>
    <updated>2020-09-22T10:11:38.947Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="/images/InnoDB-Indexes-Translation/87c01ec7gy1frkhzeordxj21kw0zke81.jpg" alt="" /></p><blockquote><p>翻译原文档地址：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-indexes.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-indexes.html</a></p></blockquote><h2 id="聚簇索引和二级索引"><a class="markdownIt-Anchor" href="#聚簇索引和二级索引"></a> 聚簇索引和二级索引</h2><p>每个<code>InnoDB</code>表都有一个特殊的索引，称为<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_clustered_index">聚簇索引</a>，用于存储行数据。通常，聚簇索引与<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_primary_key">主键</a>同义。为了从查询，插入，和其他数据操作上获得最佳性能，你必须了解<code>InnoDB</code>如果使用聚簇索引为每个表优化最常见的查找和DML操作。</p><a id="more"></a><ul><li>当你在表上定义了一个<code>PRIMARY KEY</code>，<code>InnoDB</code>将使用它作为聚簇索引。为你创建的每一个表定义一个主键。如果没有逻辑唯一且非空的列或者列集，请添加一个新的自增列，其值将自动填充。</li><li>如果你没有为你的表定义一个<code>PRIMARY KEY</code>，MySQL会在所有键列都<code>NOT NULL</code>的情况下找到第一个<code>UNIQUE</code>索引，<code>InnoDB</code>会使用它作为聚簇索引。</li><li>如果表没有<code>PRIMARY KEY</code>或合适的<code>UNIQUE</code>索引，<code>InnoDB</code>在包含行ID值的综合列上内部生成一个名为<code>GEN_CLUST_INDEX</code>的隐藏的聚簇索引。这些行由<code>InnoDB</code>分配给此类表中的行ID排序。这些行ID是一个6字节的字段，随着插入新行而单调增加。因此，按行ID排序的行是物理上按插入顺序排列。</li></ul><h3 id="聚簇索引如何加快查询速度"><a class="markdownIt-Anchor" href="#聚簇索引如何加快查询速度"></a> 聚簇索引如何加快查询速度</h3><p>通过聚簇索引访问行是快速的，因为索引搜索直接指向含所有行数据的页面。假如一个表很大，与使用不同于与索引记录的页面存储行数据的存储方式相比，聚簇索引结构通常可以节省磁盘I/O操作。</p><h3 id="二级索引如果与聚簇索引关联"><a class="markdownIt-Anchor" href="#二级索引如果与聚簇索引关联"></a> 二级索引如果与聚簇索引关联</h3><p>除聚簇索引外的所有索引都称为<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_secondary_index">二级索引</a>。在<code>InnoDB</code>里，在二级索引的每个记录都包含该行的主键列，以及为二级索引知道的列。<code>InnoDB</code>使用此主键值在聚簇索引中搜索行。</p><p>假如主键较长，则二级索引会使用更多空间，因此具有短主键是有利的。</p><p>有关利用<code>InnoDB</code>聚簇索引和二级索引的指南，查看<a href="https://dev.mysql.com/doc/refman/8.0/en/optimization-indexes.html">Section 8.3 “优化和索引”</a>。</p><h2 id="innodb索引的物理结构"><a class="markdownIt-Anchor" href="#innodb索引的物理结构"></a> InnoDB索引的物理结构</h2><p>除了空间索引，<code>InnoDB</code>索引都是<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_b_tree">B-Tree</a>数据结构。空间索引使用<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_r_tree">R-trees</a>，R-trees是用于索引多维数据的专用数据结构。索引记录存储在B-tree或R-tree数据结构的叶子页上。默认索引页的大小是16KB。</p><p>当一个新记录插入到<code>InnoDB</code>的聚簇索引时，<code>InnoDB</code>尝试让页的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>16</mn></mrow><annotation encoding="application/x-tex">1/16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">1</span><span class="mord">6</span></span></span></span>空闲，以供将来插入和更新索引记录。假如索引记录顺序（升序或降序）插入，产生的索引页大约占满<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>15</mn><mi mathvariant="normal">/</mi><mn>16</mn></mrow><annotation encoding="application/x-tex">15/16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">/</span><span class="mord">1</span><span class="mord">6</span></span></span></span>。如果以随机顺序插入记录，则页面的容量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">1/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>15</mn><mi mathvariant="normal">/</mi><mn>16</mn></mrow><annotation encoding="application/x-tex">15/16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">/</span><span class="mord">1</span><span class="mord">6</span></span></span></span>。</p><p><code>InnoDB</code>在创建或重建B-tree索引时执行批量加载。这种索引创建方法称为排序索引构建。<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_fill_factor"><code>innodb_fill_factor</code></a>配置选项定义了在排序索引构建期间填充的每个B-tree页上的空间百分比，剩余的空间供将来索引增长使用。排序索引构建不支持空间索引。更多信息查看<a href="https://dev.mysql.com/doc/refman/8.0/en/sorted-index-builds.html">Section 15.6.2.3，“排序索引构建”</a>。设置为100的<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_fill_factor"><code>innodb_fill_factor</code></a>会使聚簇索引页中的空间的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>16</mn></mrow><annotation encoding="application/x-tex">1/16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">1</span><span class="mord">6</span></span></span></span>空闲，以供将来索引增长。</p><p>如果<code>InnoDB</code>索引页的填充因子低于<code>MERGE_THRESHOLD</code>（如果未指定，默认值为50%），则<code>InnoDB</code>尝试收缩索引树以释放页。<code>MERGE_THRESHOLD</code>设置适用于B-tree和R-tree索引。更多信息，查看<a href="https://dev.mysql.com/doc/refman/8.0/en/index-page-merge-threshold.html">Section 15.8.11，“配置索引页的合并阈值”</a>。</p><p>你可以在初始化MySQL实例之前，通过设置<a href=""><code>innodb_page_size</code></a>配置选项来定义MySQL实例中所有<code>InnoDB</code>表空间的<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_page_size">页大小</a>。一旦一个实例的页大小被定义，你不能修改它，除了重新初始化实例。支持的大小有：64KB，32KB，16KB（默认），8KB和4KB。</p><p>使用特定<code>InnoDB</code>页大小的MySQL实例不能使用来自不同页面大小的实例中的数据文件或日志文件。</p><h2 id="排序索引构建"><a class="markdownIt-Anchor" href="#排序索引构建"></a> 排序索引构建</h2><p><code>InnoDB</code>在创建或重建B-tree索引时执行批量加载。这种索引创建方法称为排序索引构建。<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_fill_factor"><code>innodb_fill_factor</code></a>配置选项定义了在排序索引构建期间填充的每个B-tree页上的空间百分比，剩余的空间供将来索引增长使用。排序索引构建不支持空间索引。</p><p>一个索引构建有三个阶段。在第一阶段，扫描<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_clustered_index">聚簇索引</a>，生成索引项并添加到排序缓冲区。当<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_sort_buffer">排序缓冲区</a>满了，索引项在排序后，写入到临时中间文件。此过程也称为“<code>运行（run）</code>”。在第二阶段，在一个或多个<code>runs</code>写入到临时中间文件中，对文件的条目执行合并排序。在第三阶段也是最后节点，排序后的条目插入到<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_b_tree">B-tree</a>中。</p><p>在介绍排序索引构建前，通过插入API将索引项一次插入到B-tree的一条记录中。这个方法涉及打开B-tree<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_cursor">游标（cursor）</a>以找到插入位置，然后使用<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_optimistic">乐观（optimistic）</a>插入将条目插入B-tree页中。如果由于页满了导致插入失败的，将使用<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_pessimistic">悲观（pessimistic）</a>插入，它涉及到打开一个B-tree游标并根据需要拆分和合并B-tree节点以找到索引项空间。这种“自上而下”的构建索引方法的缺点是搜索插入位置的成本和B-tree节点的不断拆分和合并的成本。</p><p>排序索引构建是使用“自下而上”方法构建索引。使用这种方法，B-tree的所有级别都包含了对最右叶子页的引用。在必要的B-tree深度处分配最右叶子页，并根据其排序顺序插入条目。一旦叶子页满了，节点指针将附加到父页，并且为下一个插入分配同级叶子页。这个过程将一直持续到插入所有索引项为止，这可能会导致插入到根级别。分配同级页后，将释放对先前固定的叶子页的引用，最新分配的叶子页将成为为最右叶子页和新默认插入位置。</p><h3 id="保留b-tree页空间以供为了索引增长"><a class="markdownIt-Anchor" href="#保留b-tree页空间以供为了索引增长"></a> 保留B-tree页空间以供为了索引增长</h3><p>要为将来的索引增长留出空间，可以使用<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_fill_factor"><code>innodb_fill_factor</code></a>配置选项设置保留B-tree空间的百分比。例如，将<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_fill_factor"><code>innodb_fill_factor</code></a>设置为80可以在排序索引构建期间为B-tree空间保留20%的空间。此设置适用于B-tree叶子页和非叶子页。不适用于用于<code>TEXT</code>或<code>BLOB</code>索引项的外部页。保留的空间量不一定和配置完全相同，<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_fill_factor"><code>innodb_fill_factor</code></a>值解释为提示而不是强制约束。</p><h3 id="排序索引构建和全文索引支持"><a class="markdownIt-Anchor" href="#排序索引构建和全文索引支持"></a> 排序索引构建和全文索引支持</h3><p>全文索引支持排序索引构建。以前，SQL是用于将索引项插入到全文索引的。</p><h3 id="排序索引构建和压缩表"><a class="markdownIt-Anchor" href="#排序索引构建和压缩表"></a> 排序索引构建和压缩表</h3><p>对于<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_compression">压缩表</a>，以前的索引创建方法是将索引项附加到压缩和未压缩页面上的。修改日志（表示压缩页面上的可用空间）已满是，压缩页将重新压缩。假如由于缺乏空间导致压缩失败，页将被拆分。使用排序索引构建，索引项只附加到未压缩页上。当未压缩页满了时，未压缩页会被压缩。自适应填充用于确保大多数情况下压缩成功，但是假如压缩失败，页会被拆分并再次尝试重新压缩。此过程一直持续到压缩成功。关于B-Tree页压缩的更多信息，查看<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-compression-internals.html">Section 15.9.1.5，“压缩如何为InnoDB表工作”</a>。</p><h3 id="排序索引构建和重做日志记录"><a class="markdownIt-Anchor" href="#排序索引构建和重做日志记录"></a> 排序索引构建和重做日志记录</h3><p>在排序索引构建期间，重做日志记录是被禁用的。反而，有一个<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_checkpoint">检查点（checkpoint）</a>来确保索引构建能够经受崩溃或失败。检查点强制将所有脏页写入磁盘。在排序索引构建期间，<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_page_cleaner">页面清洁器</a>线程定期发出清理脏页的信号，以确保检查点操作能够被快速处理。通常，当清洁页面数低于设置的阈值时，页面清洁器线程将刷新脏页。对排序索引构建来说，及时清除脏页，以减少检查点开销（overhead），并行I/O和CPU活动。</p><h3 id="排序索引构建和优化器统计"><a class="markdownIt-Anchor" href="#排序索引构建和优化器统计"></a> 排序索引构建和优化器统计</h3><p>排序索引构建在优化器统计的结果与由以前索引创建方法生成的那些是不同的。由于用于填充索引的算法不同，统计信息是有差异存在（预计不会影响工作负载性能）。</p><h2 id="innodb全文索引"><a class="markdownIt-Anchor" href="#innodb全文索引"></a> InnoDB全文索引</h2><p>创建在基于文本的列（<a href="https://dev.mysql.com/doc/refman/8.0/en/char.html"><code>CHAR</code></a>，<a href="https://dev.mysql.com/doc/refman/8.0/en/char.html"><code>VARCHAR</code></a>或<a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html"><code>TEXT</code></a>列）上的<code>全文（FULLTEXT）</code>索引，以帮助加快对那些列中包含的数据查询和DML操作，忽略定义为停用词的任何单词。</p><p><code>全文（FULLTEXT）</code>索引定义为<a href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html"><code>CREATE TABLE</code></a>语句或使用<a href="https://dev.mysql.com/doc/refman/8.0/en/alter-table.html"><code>ALTER TABLE</code></a>或<a href="https://dev.mysql.com/doc/refman/8.0/en/create-index.html"><code>CREATE INDEX</code></a>添加到现有表中。</p><p>使用<a href="https://dev.mysql.com/doc/refman/8.0/en/fulltext-search.html#function_match"><code>MATCH() ... AGAINST</code></a>语法执行全文搜索。有关使用信息，查看<a href="https://dev.mysql.com/doc/refman/8.0/en/fulltext-search.html">Section 12.9，“全文搜索功能”</a></p><p>本节以下主题介绍了<code>InnoDB</code>的<code>全文（FULLTEXT）</code>索引：</p><ul><li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-fulltext-index.html#innodb-fulltext-index-design">InnoDB Full-Text Index Design</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-fulltext-index.html#innodb-fulltext-index-tables">InnoDB Full-Text Index Tables</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-fulltext-index.html#innodb-fulltext-index-cache">InnoDB Full-Text Index Cache</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-fulltext-index.html#innodb-fulltext-index-docid">InnoDB Full-Text Index Document ID and FTS_DOC_ID Column</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-fulltext-index.html#innodb-fulltext-index-deletion">InnoDB Full-Text Index Deletion Handling</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-fulltext-index.html#innodb-fulltext-index-transaction">InnoDB Full-Text Index Transaction Handling</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-fulltext-index.html#innodb-fulltext-index-monitoring">Monitoring InnoDB Full-Text Indexes</a></li></ul><p>…TODO</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/InnoDB-Indexes-Translation/87c01ec7gy1frkhzeordxj21kw0zke81.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;翻译原文档地址：&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/innodb-indexes.html&quot;&gt;https://dev.mysql.com/doc/refman/8.0/en/innodb-indexes.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;聚簇索引和二级索引&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#聚簇索引和二级索引&quot;&gt;&lt;/a&gt; 聚簇索引和二级索引&lt;/h2&gt;
&lt;p&gt;每个&lt;code&gt;InnoDB&lt;/code&gt;表都有一个特殊的索引，称为&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_clustered_index&quot;&gt;聚簇索引&lt;/a&gt;，用于存储行数据。通常，聚簇索引与&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_primary_key&quot;&gt;主键&lt;/a&gt;同义。为了从查询，插入，和其他数据操作上获得最佳性能，你必须了解&lt;code&gt;InnoDB&lt;/code&gt;如果使用聚簇索引为每个表优化最常见的查找和DML操作。&lt;/p&gt;</summary>
    
    
    
    
    <category term="InnoDB" scheme="https://mikado.drrr.app/tags/InnoDB/"/>
    
    <category term="MySQL" scheme="https://mikado.drrr.app/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>译：InnoDB锁定</title>
    <link href="https://mikado.drrr.app/InnoDB-Locking-Translation/"/>
    <id>https://mikado.drrr.app/InnoDB-Locking-Translation/</id>
    <published>2020-04-06T05:24:52.000Z</published>
    <updated>2020-09-22T10:11:38.947Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="/images/InnoDB-Locking-Translation/69174779_p0.jpg" alt="" /></p><blockquote><p>翻译文档地址：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html</a></p></blockquote><h2 id="共享锁与排他锁shared-and-exclusive-locks"><a class="markdownIt-Anchor" href="#共享锁与排他锁shared-and-exclusive-locks"></a> 共享锁与排他锁（Shared and Exclusive Locks）</h2><p><code>InnoDB</code>实现了标准行锁定，其中有两种类型锁：<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_shared_lock">共享（<code>S</code>）锁</a> 和 <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_exclusive_lock">排他（<code>X</code>）锁</a></p><ul><li><a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_shared_lock">共享锁</a>允许持有该锁的事务读取一行。</li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_exclusive_lock">排他锁</a>允许持有该所的事务更新或删除一行。</li></ul><p>假如事务<code>T1</code>在行<code>r</code>上持有共享（<code>S</code>）锁，然后，不同的事务<code>T2</code>请求行<code>r</code>上的锁时，处理方法如下：</p><ul><li><code>T2</code>对<code>S</code>锁的请求会被立即同意（granted immediately）。结果是，<code>T1</code>和<code>T2</code>在<code>r</code>上都将持有<code>S</code>锁。</li><li><code>T2</code>对<code>X</code>锁的请求不会被立即同意。</li></ul><p>如果事务<code>T1</code>持有对行<code>r</code>的排他（<code>X</code>）锁，来自不同事务<code>T2</code>的请求<code>r</code>上的两种类型的锁都不会被立即同意。反而，事务<code>T2</code>必须等待事务<code>T1</code>释放对行<code>r</code>的锁。</p><a id="more"></a><h2 id="意向锁intention-locks"><a class="markdownIt-Anchor" href="#意向锁intention-locks"></a> 意向锁（Intention Locks）</h2><p><code>InnoDB</code>支持*多粒度锁（multiple granularity locking）*来允许行锁和表锁共存。举个例子，像<a href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html"><code>LOCK TABLES ... WRITE</code></a>在特殊表中会持有排他锁（一个<code>X</code>锁）。为了锁在多粒度级别下可行，<code>InnoDB</code>使用了<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_intention_lock">意向锁</a>。意向锁是表级锁，表明一个事务稍后对表中的行需要哪种类型的锁（共享或排他）。有两种类型的意向锁：</p><ul><li><a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_intention_shared_lock">意向共享锁</a>（<code>IS</code>）表明事务打算在表中的各个行上设置<em>共享</em>锁。</li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_intention_exclusive_lock">意向排他锁</a>（<code>IX</code>）表明事务打算在表中的各个行上设置排他锁。</li></ul><p>例如，<a href="https://dev.mysql.com/doc/refman/8.0/en/select.html"><code>SELECT ... FOR SHARE</code></a>设置一个<code>IS</code>锁，而<a href="https://dev.mysql.com/doc/refman/8.0/en/select.html"><code>SELECT ... FOR UPDATE</code></a>设置一个<code>IX</code>锁。</p><p>意向锁协议如下：</p><ul><li>在一个事务获取表中某行的共享锁之前，它必须首先获得该表中的<code>IS</code>锁或更强的锁。</li><li>在一个事务获取表中某行的排他锁之前，它必须首先获得该表中的<code>IX</code>锁。</li></ul><p>表级锁类型的兼容性整理在以下表中。</p><table><thead><tr><th></th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>X</td><td>冲突</td><td>冲突</td><td>冲突</td><td>冲突</td></tr><tr><td>IX</td><td>冲突</td><td>兼容</td><td>冲突</td><td>兼容</td></tr><tr><td>S</td><td>冲突</td><td>冲突</td><td>兼容</td><td>兼容</td></tr><tr><td>IS</td><td>冲突</td><td>兼容</td><td>兼容</td><td>兼容</td></tr></tbody></table><p>如果事务的一个锁请求与现有锁是兼容的，则锁请求会被同意（granted），但是如果与现有锁冲突的，则锁请求不会被同意。事务会等待直到冲突的现有锁被释放。如果一个锁请求与现有锁冲突并且由于可能导致死锁而无法同意，则会发生错误。</p><p>意向锁除了全表请求外不阻止任何操作（例如，<a href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html"><code>LOCK TABLES ... WRITE</code></a>）。意向锁主要的目的是表明某人（someone）正锁定或将要锁定表中的行。</p><p>在<a href="https://dev.mysql.com/doc/refman/8.0/en/show-engine.html"><code>SHOW ENGINE INNODB STATUS</code></a>和<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-standard-monitor.html">InnoDB监视器</a>输出中，意向锁的事务数据看起来类似以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TABLE LOCK table &#96;test&#96;.&#96;t&#96; trx id 10080 lock mode IX</span><br></pre></td></tr></table></figure><h2 id="记录锁record-locks"><a class="markdownIt-Anchor" href="#记录锁record-locks"></a> 记录锁（Record Locks）</h2><p>记录锁是在索引记录上的一个锁。例如，<code>SELECT C! FROM t WHERE c1 = 10 FOR UPDATE;</code>防止其他事务插入，更新或删除<code>t.c1</code>的值为<code>10</code>的行。</p><p>记录锁总是锁定索引记录，即使没有定义索引的表。对于这种情况，<code>InnoDB</code>创建一个隐藏的聚簇索引，并将改索引用于记录锁。查看<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html">Section 15.6.2.1，“聚簇索引和二级索引”</a></p><p>在<a href="https://dev.mysql.com/doc/refman/8.0/en/show-engine.html"><code>SHOW ENGINE INNODB STATUS</code></a>和<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-standard-monitor.html">InnoDB监视器</a>输出中，记录锁的事务数据看起来类似以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id 58 page no 3 n bits 72 index &#96;PRIMARY&#96; of table &#96;test&#96;.&#96;t&#96; </span><br><span class="line">trx id 10078 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 6; hex 00000000274f; asc     &#39;O;;</span><br><span class="line">2: len 7; hex b60000019d0110; asc        ;;</span><br></pre></td></tr></table></figure><h2 id="间隙锁gap-locks"><a class="markdownIt-Anchor" href="#间隙锁gap-locks"></a> 间隙锁（Gap Locks）</h2><p>间隙锁是在索引数据之间的间隙的锁定，或在第一个索引记录之前或最后一个索引记录之后的间隙的锁定。例如，<code>SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;</code>会防止其他事务将<code>15</code>插入到<code>t.c1</code>列中，无论该列中是否已经有这样的值，因为该范围的所有现有值之间的间隙是被锁定的。</p><p>间隙可能跨越单个索引值，多个索引值，甚至为空。</p><p>间隙锁是在性能和并发性之间权衡的一部分，并且在某些事务隔离级别而非其他级别使用。</p><p>对于使用唯一索引锁行来搜索唯一行的语句不需要间隙锁。（这不包括搜索条件仅包含多列唯一索引的某些列的情况；在这个情况下，会发生间隙锁定。）例如，假如<code>id</code>列有个唯一索引，以下语句进队<code>id</code>值为100的行使用记录锁，并且其他会话在前间隙插入行也是没关系的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM child WHERE id &#x3D; 100;</span><br></pre></td></tr></table></figure><p>如果<code>id</code>没有索引或有非唯一索引，则该语句会锁定前间隙。</p><p>值得注意的是，可以通过不同事务将冲突的锁能保持在间隙上。例如，事务A在间隙上保留一个共享间隙锁（gap S-lock），而事务B在同个间隙上保留排他间隙锁（gap X-lock）。允许冲突间隙锁的原因是，如果从索引中清除记录，必须合并有不同事务上在记录上保留的间隙锁。</p><p><code>InnoDB</code>中间隙锁是“完全抑制的（purely inhibitive）”，这意味着它们的目的是阻止其他事务插入间隙。间隙锁是可以共存的。一个间隙锁被一个事务获取不会阻止其他事务在同个间隙获取间隙锁。共享和排他间隙锁没有区别。它们不互相冲突，并且执行相同的功能。</p><p>间隙锁能被直接禁用。如果你将事务隔离级别修改为<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-committed">已提交读（READ COMMITED）</a>。在这种情况下，间隙锁在搜索和索引扫描是被禁用的，仅用于外键约束检查和重复键检查。</p><p>使用<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-committed">已提交读（READ COMMITED）</a>的隔离级别还有其他影响。MySQL评估<code>WHERE</code>条件后，不匹配的记录锁将会被释放。对于<code>UPDATE</code>语句，<code>InnoDB</code>进行“半一致（semi-consistent）”读。它会返回最后提交版本给MySQL，以便MySQL可以确定该行是否与<a href="https://dev.mysql.com/doc/refman/8.0/en/update.html"><code>UPDATE</code></a>的<code>WHERE</code>条件匹配。</p><h2 id="next-key-locks"><a class="markdownIt-Anchor" href="#next-key-locks"></a> Next-Key Locks</h2><p>Next-Key锁是索引记录上的记录锁和索引记录之前间隙上的间隙锁的组合。</p><p><code>InnoDB</code>执行行级锁的方式是，当它搜索或扫描表索引时，会在遇到的索引上设置共享或排他锁。从而，行级锁实际上是索引记录锁。在索引记录上的next-key锁也能影响该索引记录之前“间隙”。那就是，next-key锁是一个索引记录锁加上在索引记录之前间隙的间隙锁。假如一个会话在记录<code>R</code>上有一个共享或者排他锁，另一个会话不能按照索引顺序在<code>R</code>之前间隙中插入一条新索引记录。</p><p>假设一个索引包含了值10，11，13和20。该索引的next-key锁可能覆盖以下区间，其中，圆括号表示排除区间端点，方括号标段包含端点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(negative infinity, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure><p>最后的区间，next-key锁锁了索引的最大值之后的间隙以及“最高（supremum）”伪记录（pseudo-record）的值高于实际在索引的任何值。最高（The supremum）不是一个真实的索引记录，所以，实际上，这个next-key锁只锁最大索引值之后的间隙。</p><p>默认情况下，<code>InnoDB</code>运行在<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read">可重复读（REPEATABLE READ）</a>的事务隔离级别下。这种情况下，<code>InnoDB</code>使用next-key锁进行搜索和索引扫描，从而防止了幻象行（phantom row）（查看<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-next-key-locking.html">Section 15.7.4，”Phantom Rows&quot;</a>)</p><p>在<a href="https://dev.mysql.com/doc/refman/8.0/en/show-engine.html"><code>SHOW ENGINE INNODB STATUS</code></a>和<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-standard-monitor.html">InnoDB监视器</a>输出中，next-key锁的事务数据看起来类似以下内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t` </span><br><span class="line">trx id 10080 lock_mode X</span><br><span class="line">Record <span class="keyword">lock</span>, <span class="keyword">heap</span> <span class="keyword">no</span> <span class="number">1</span> <span class="keyword">PHYSICAL</span> <span class="built_in">RECORD</span>: n_fields <span class="number">1</span>; compact format; info bits 0</span><br><span class="line"> 0: len 8; hex 73757072656d756d; asc supremum;;</span><br><span class="line"></span><br><span class="line">Record <span class="keyword">lock</span>, <span class="keyword">heap</span> <span class="keyword">no</span> <span class="number">2</span> <span class="keyword">PHYSICAL</span> <span class="built_in">RECORD</span>: n_fields <span class="number">3</span>; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 6; hex 00000000274f; asc     &#x27;O;;</span><br><span class="line">2: len 7; hex b60000019d0110; asc        ;;</span><br></pre></td></tr></table></figure><h2 id="插入意向锁"><a class="markdownIt-Anchor" href="#插入意向锁"></a> 插入意向锁</h2><p>插入意向锁是一种在行插入之前通过<a href="https://dev.mysql.com/doc/refman/8.0/en/insert.html">INSERT</a>操作设置的间隙锁。如果插入到同一索引间隙的多个事务不在间隙中的相同位置插入，则此锁表示希望以这样的一种方式进行插入，即插入到同一索引间隙的多个事务无需相互等待。假设，有索引记录的值为4和7。尝试插入值5和6的单个事务，分别在获得插入行的排他锁之前，每一个事务先用插入意向锁来锁定4和7之间的间隙，但是由于行是没有冲突的，所以彼此不会阻塞。</p><p>下列示例展示了事务在插入记录上获取排他锁之前获取插入意图锁。这个例子包含了两个客户端，A和B。</p><p>客户端A创建包含两个索引记录（90和102）的表，接着开始一个事务，在ID大于100的索引记录上放置一个排他锁。这个排他锁包含了记录102之前的间隙锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE child (id int(11) NOT NULL, PRIMARY KEY(id)) ENGINE&#x3D;InnoDB;</span><br><span class="line">mysql&gt; INSERT INTO child (id) values (90),(102);</span><br><span class="line"></span><br><span class="line">mysql&gt; START TRANSACTION;</span><br><span class="line">mysql&gt; SELECT * FROM child WHERE id &gt; 100 FOR UPDATE;</span><br><span class="line">+-----+</span><br><span class="line">| id  |</span><br><span class="line">+-----+</span><br><span class="line">| 102 |</span><br><span class="line">+-----+</span><br></pre></td></tr></table></figure><p>客户端B开启一个事务，插入一个记录到间隙中。这个事务在等待获取一个排他锁时获取了一个插入意图锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; START TRANSACTION;</span><br><span class="line">mysql&gt; INSERT INTO child (id) VALUES (101);</span><br></pre></td></tr></table></figure><p>在<a href="https://dev.mysql.com/doc/refman/8.0/en/show-engine.html"><code>SHOW ENGINE INNODB STATUS</code></a>和<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-standard-monitor.html">InnoDB监视器</a>输出中，插入意图锁的事务数据看起来类似以下内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id 31 page no 3 n bits 72 index `PRIMARY` of table `test`.`child`</span><br><span class="line">trx id 8731 lock_mode X locks gap before rec <span class="keyword">insert</span> intention waiting</span><br><span class="line"><span class="built_in">Record</span> <span class="keyword">lock</span>, <span class="keyword">heap</span> <span class="keyword">no</span> <span class="number">3</span> <span class="keyword">PHYSICAL</span> <span class="built_in">RECORD</span>: n_fields <span class="number">3</span>; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 80000066; asc    f;;</span><br><span class="line"> 1: len 6; hex 000000002215; asc     &quot; ;;</span><br><span class="line"> 2: len 7; hex 9000000172011c; asc     r  ;;...</span><br></pre></td></tr></table></figure><h2 id="自增锁auto-inc-locks"><a class="markdownIt-Anchor" href="#自增锁auto-inc-locks"></a> 自增锁（AUTO-INC Locks）</h2><p>自增锁是一种特殊的表级锁，由事务插入具有<code>AUTO_INCREMENT</code>列的表中获得。在最简单的情况中，如果一个事务正在表中插入数据，任意其他事务必须等待执行自己插入操作，因此，第一个事务插入的行将收到联系的主键值。</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_autoinc_lock_mode"><code>innodb_autoinc_lock_mode</code></a>配置选项用于控制自增锁定的算法。它允许你选择如何在可预测的自增值和插入操作的最大并发性之间权衡。</p><p>更多信息，查看 <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html">Section 15.6.1.6，“AUTO_INCREMENT Handing in InnoDB”</a></p><h2 id="空间索引的谓词锁"><a class="markdownIt-Anchor" href="#空间索引的谓词锁"></a> 空间索引的谓词锁</h2><p><code>InnoDB</code>支持包含空间列（spatial columns）的<code>空间（SPATIAL）</code>索引。（查看 <a href="https://dev.mysql.com/doc/refman/8.0/en/optimizing-spatial-analysis.html">Section 11.4.8，“Optimizing Spatial Analysis”</a>）。</p><p>为了处理涉及<code>空间（SPATIAL）</code>索引操作的锁定，next-key锁不能很好地支持<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read"><code>REPEATABLE READ</code></a>或<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_serializable"><code>SERIALIZABLE</code></a>事务隔离级别。多维数据中没有绝对排序概念，因此不清楚哪一个是“下一个”键。</p><p>为了支持具有<code>空间（SPATIAL）</code>索引的表的隔离级别。<code>InnoDB</code>使用了谓词锁。<code>空间（SPATIAL）</code>索引包含了最小边界矩形（MBR）值，因此<code>InnoDB</code>通过在用于查询的MBR值上设置谓词锁来强制对索引进行一致的读取。其他事务不能插入或修改匹配查询条件的行。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/InnoDB-Locking-Translation/69174779_p0.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;翻译文档地址：&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html&quot;&gt;https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;共享锁与排他锁shared-and-exclusive-locks&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#共享锁与排他锁shared-and-exclusive-locks&quot;&gt;&lt;/a&gt; 共享锁与排他锁（Shared and Exclusive Locks）&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;InnoDB&lt;/code&gt;实现了标准行锁定，其中有两种类型锁：&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_shared_lock&quot;&gt;共享（&lt;code&gt;S&lt;/code&gt;）锁&lt;/a&gt; 和 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_exclusive_lock&quot;&gt;排他（&lt;code&gt;X&lt;/code&gt;）锁&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_shared_lock&quot;&gt;共享锁&lt;/a&gt;允许持有该锁的事务读取一行。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_exclusive_lock&quot;&gt;排他锁&lt;/a&gt;允许持有该所的事务更新或删除一行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假如事务&lt;code&gt;T1&lt;/code&gt;在行&lt;code&gt;r&lt;/code&gt;上持有共享（&lt;code&gt;S&lt;/code&gt;）锁，然后，不同的事务&lt;code&gt;T2&lt;/code&gt;请求行&lt;code&gt;r&lt;/code&gt;上的锁时，处理方法如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T2&lt;/code&gt;对&lt;code&gt;S&lt;/code&gt;锁的请求会被立即同意（granted immediately）。结果是，&lt;code&gt;T1&lt;/code&gt;和&lt;code&gt;T2&lt;/code&gt;在&lt;code&gt;r&lt;/code&gt;上都将持有&lt;code&gt;S&lt;/code&gt;锁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T2&lt;/code&gt;对&lt;code&gt;X&lt;/code&gt;锁的请求不会被立即同意。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果事务&lt;code&gt;T1&lt;/code&gt;持有对行&lt;code&gt;r&lt;/code&gt;的排他（&lt;code&gt;X&lt;/code&gt;）锁，来自不同事务&lt;code&gt;T2&lt;/code&gt;的请求&lt;code&gt;r&lt;/code&gt;上的两种类型的锁都不会被立即同意。反而，事务&lt;code&gt;T2&lt;/code&gt;必须等待事务&lt;code&gt;T1&lt;/code&gt;释放对行&lt;code&gt;r&lt;/code&gt;的锁。&lt;/p&gt;</summary>
    
    
    
    
    <category term="InnoDB" scheme="https://mikado.drrr.app/tags/InnoDB/"/>
    
    <category term="MySQL" scheme="https://mikado.drrr.app/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>哈希冲突</title>
    <link href="https://mikado.drrr.app/Hash-Collisions/"/>
    <id>https://mikado.drrr.app/Hash-Collisions/</id>
    <published>2020-03-01T14:39:11.000Z</published>
    <updated>2020-09-22T10:11:38.947Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="/images/Hash-Collisions/b32662efc5800fdcd75e0e9205072772.jpg" alt="" /></p><h2 id="hash-函数"><a class="markdownIt-Anchor" href="#hash-函数"></a> Hash 函数</h2><p>在有限的数组存储空间中，不存在一个Hash函数是能完全避免Hash冲突的。</p><h2 id="hash-冲突"><a class="markdownIt-Anchor" href="#hash-冲突"></a> Hash 冲突</h2><p>发生了Hash冲突，解决方法有两种，开放寻址法（Open addressing）和链表法(Chaining)。</p><a id="more"></a><ul><li>开放寻址法</li></ul><p>开放寻址法的核心思想是，出现了Hash冲突就重新找空闲的位置，将其插入。一个简单的探测方法就是<strong>线性探测</strong>（Linear Probing)。</p><p>图例：</p><p><img data-src="/images/Hash-Collisions/Hash-Collisions-Open-Addressing-Linear-Probing-Example.jpg" alt="" /></p><p>从图中可以看出，被Hash函数计算出的位置已经有数据存在了，就往下一位放，如果到底都无法插入，就从头开始找。</p><p>这个方法的删除操作稍微有些特别。我们不能单纯地把要删除的元素设置为空。假如有一个Hash冲突后的数据，要查找是否存在，通过线性探测计算出空闲位置，但是空闲位置上的数据为之前删除的，就会认定不存在。导致查找结果失败。</p><p>解决方法就是设置个特殊标记，标为这个数据为删除的。</p><p>除了线性探测方法之外，还有另外两种比较经典的探测方法，<strong>二次探测</strong>（Quadratic probing）和<strong>双重Hash</strong>（Double hashing）。</p><p>所谓二次探测，跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 hash(key)+0，hash(key)+1，hash(key)+2…而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0，hash(key)+1<sup>2，hash(key)+2</sup>2…</p><p>双重Hash，就是不仅要使用一个Hash函数。使用一组Hash函数，hash1、hash2、hash3…使用第一个Hash函数（hash1），计算出位置，结果不为空，就用第二个Hash函数（hash2），依次类推。</p><p>不管采用哪种探测方法，当Hash表中空闲位置不多的时候，Hash冲突的概率就会大大提高。为了尽可能保证Hash表的操作效率，一般情况下，我们会尽可能保证Hash表中有一定比例的空闲槽位。我们用<strong>装载因子</strong>（load factor）来表示空位的多少。</p><p>装载因子的计算公式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hash表的装载因子 &#x3D; 填入表中的元素个数 &#x2F; Hash表的长度</span><br></pre></td></tr></table></figure><p>装载因子越大，说明空闲位置越少，冲突越多，Hash表的性能会下降…对于开放定址法，装载因子是特别重要因素，应严格限制在0.7-0.8以下。超过0.8，查表时的CPU缓存不命中（cache missing）按照指数曲线上升。因此，一些采用开放定址法的hash库，如Java的系统库限制了装载因子为0.75，超过此值将resizeHash表。</p><ul><li>链表法</li></ul><p>链表法是比较常用的hash冲突解决方法。在Hash表中，每个“桶（Bucket）”或者“槽（Slot）”会对应一个列表</p><p>在插入的时候，计算出位置，如果位置不为空，则会插入到桶的链表中。</p><p>图例：</p><p><img data-src="/images/Hash-Collisions/Hash-Collisions-Chaining-Example.jpg" alt="" /></p><h2 id="装载因子"><a class="markdownIt-Anchor" href="#装载因子"></a> 装载因子</h2><p>装载因子是表示Hsah表中元素的填满的程度，该值越大，说明Hash表中的元素越多，空闲的位置越少，Hash冲突的概率越大。不仅插入数据的过程要多次寻址或者拉很长的链表，查找过程也会因此变得很慢。</p><p>对于动态Hash表来说，数据集合是频繁变动的，我们事先无法预估将要加入的数据个数，所以我也无法去事先申请一个足够大的Hash表。随者数据慢慢加入，装载因子就会慢慢变大。当装载因子大到一定程度之后，Hash冲突就会变得不可接受。</p><p>这个时候就需要对Hash表“动态扩容”了。针对Hash表，当装载因子过大时，我们也可以进行动态扩容，重新申请一个更大的Hash表，将数据搬移到新Hash表中。假设每次扩容我们都申请一个原来Hash表大小两倍的空间。如果原来Hash表的装载因子是0.8，那经过扩容之后，新Hash表的装载因子就下降为原来的一半，变成了0.4.针对数组的扩容，数据搬移操作比较简单。但是，针对Hash表的扩容，数据搬移操作要复杂很多。因为Hash表的大小变了，数据的存储位置也变了，所以我们需要通过Hash函数重新计算每个数据的存储位置。</p><p>Hash表数据不多时，数据搬移操作基本不费时间和空间，但是如果数据量很大时，搬移操作就很耗时耗空间。</p><p>解决方法是：一个新数据进来时，申请一个新的Hash表，并计算位置插入到新的Hash表。旧的Hash表数据不变。再有新的数据进来时，插入到新的Hash表，并拿旧Hash表的一个数据计算在新的Hash表中的位置并插入，重复上述过程，旧Hash表的数据就一点点的到新的Hash表中。</p><p>上述解决方法的查询顺序就是现在新的Hash表中查找，如果不存在再去旧的Hash表中查找，如果再没有，就是不存在了。</p><h2 id="如何选择hash冲突解决方法"><a class="markdownIt-Anchor" href="#如何选择hash冲突解决方法"></a> 如何选择Hash冲突解决方法？</h2><ul><li>开放寻址法</li></ul><p>由于开放寻址法删除数据比较麻烦，需要标记已删除数据。在开放寻址法中，所有数据都放在一个数组里，比起链表法，开放寻址法的冲突代价更高。</p><p>所以当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是Java 中的ThreadLocalMap使用开放寻址法解决Hash冲突的原因。</p><ul><li>链表法</li></ul><p>首先，链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。</p><p>链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于1的情况。接近1时，就可能会有大量的Hash冲突，致大量的探测、再Hash等，性能会下降很多。但是对于链表法来说，只要Hash函数的值随机均匀，即便装载因子变成10，也就是链表的长度变长了而已。虽然查找效率有所下降，但是比起顺序查找还是快很多。</p><p>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/Hash-Collisions/b32662efc5800fdcd75e0e9205072772.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;hash-函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#hash-函数&quot;&gt;&lt;/a&gt; Hash 函数&lt;/h2&gt;
&lt;p&gt;在有限的数组存储空间中，不存在一个Hash函数是能完全避免Hash冲突的。&lt;/p&gt;
&lt;h2 id=&quot;hash-冲突&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#hash-冲突&quot;&gt;&lt;/a&gt; Hash 冲突&lt;/h2&gt;
&lt;p&gt;发生了Hash冲突，解决方法有两种，开放寻址法（Open addressing）和链表法(Chaining)。&lt;/p&gt;</summary>
    
    
    
    
    <category term="hash" scheme="https://mikado.drrr.app/tags/hash/"/>
    
    <category term="Data Struct" scheme="https://mikado.drrr.app/tags/Data-Struct/"/>
    
  </entry>
  
  <entry>
    <title>TCP-协议</title>
    <link href="https://mikado.drrr.app/TCP-Protocol/"/>
    <id>https://mikado.drrr.app/TCP-Protocol/</id>
    <published>2019-08-29T14:30:18.000Z</published>
    <updated>2020-09-22T10:11:38.947Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="/images/TCP-Protocol/a15b4afegy1fmviz5449mj21hc0u01kx.jpg" alt="" /></p><h2 id="tcp-的特性"><a class="markdownIt-Anchor" href="#tcp-的特性"></a> TCP 的特性</h2><ul><li>TCP 提供一种面向连接的、可靠的字节流服务</li><li>在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP</li><li>TCP 使用校验和，确认和重传机制来保证可靠传输</li><li>TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复</li><li>TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li></ul><p><strong>注意</strong>：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。</p><a id="more"></a><h2 id="三次握手与四次挥手"><a class="markdownIt-Anchor" href="#三次握手与四次挥手"></a> 三次握手与四次挥手</h2><p>所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。</p><p>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。</p><ul><li><p>第一次握手(SYN=1, seq=x)</p><p>客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。</p><p>发送完毕后，客户端进入 SYN_SEND 状态。</p></li><li><p>第二次握手(SYN=1, ACK=1, seq=y,  ACKnum=x+1)</p><p>服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。</p></li><li><p>第三次握手(ACK=1，ACKnum=y+1)</p><p>客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1</p><p>发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。</p></li></ul><p>三次握手的过程的示意图如下：</p><p><img data-src="/images/TCP-Protocol/tcp-connection-made-three-way-handshake.png" alt="three-way-handshake" /></p><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 <code>close()</code> 操作即可产生挥手操作。</p><ul><li><p>第一次挥手(FIN=1，seq=x)</p><p>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p><p>发送完毕后，客户端进入 <code>FIN_WAIT_1</code> 状态。</p></li><li><p>第二次挥手(ACK=1，ACKnum=x+1)</p><p>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。</p><p>发送完毕后，服务器端进入 <code>CLOSE_WAIT</code> 状态，客户端接收到这个确认包之后，进入 <code>FIN_WAIT_2</code> 状态，等待服务器端关闭连接。</p></li><li><p>第三次挥手(FIN=1，seq=y)</p><p>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。</p><p>发送完毕后，服务器端进入 <code>LAST_ACK</code> 状态，等待来自客户端的最后一个ACK。</p></li><li><p>第四次挥手(ACK=1，ACKnum=y+1)</p><p>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 <code>TIME_WAIT</code>状态，等待可能出现的要求重传的 ACK 包。</p><p>服务器端接收到这个确认包之后，关闭连接，进入 <code>CLOSED</code> 状态。</p><p>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 <code>CLOSED</code> 状态。</p></li></ul><p>四次挥手的示意图如下：</p><p><img data-src="/images/TCP-Protocol/tcp-connection-closed-four-way-handshake.png" alt="four-way-handshake" /></p><h2 id="syn攻击"><a class="markdownIt-Anchor" href="#syn攻击"></a> SYN攻击</h2><ul><li><p>什么是 SYN 攻击（SYN Flood）？</p><p>在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态.</p><p>SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。</p><p>SYN 攻击是一种典型的 DoS/DDoS 攻击。</p></li><li><p>如何检测 SYN 攻击？</p><p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p></li><li><p>如何防御 SYN 攻击？</p><p>SYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：</p><ul><li>缩短超时（SYN Timeout）时间</li><li>增加最大半连接数</li><li>过滤网关防护</li><li>SYN cookies技术</li></ul></li></ul><h2 id="tcp-keepalive"><a class="markdownIt-Anchor" href="#tcp-keepalive"></a> TCP KeepAlive</h2><p>TCP 的连接，实际上是一种纯软件层面的概念，在物理层面并没有“连接”这种概念。TCP 通信双方建立交互的连接，但是并不是一直存在数据交互，有些连接会在数据交互完毕后，主动释放连接，而有些不会。在长时间无数据交互的时间段内，交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些 TCP 连接并未来得及正常释放，在软件层面上，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，为了解决这个问题，在传输层可以利用 TCP 的 KeepAlive 机制实现来实现。主流的操作系统基本都在内核里支持了这个特性。</p><p>TCP KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。</p><p><a href="http://www.tldp.org/HOWTO/html_single/TCP-Keepalive-HOWTO/">TCP-Keepalive-HOWTO</a> 有对 TCP KeepAlive 特性的详细介绍，有兴趣的同学可以参考。这里主要说一下，TCP KeepAlive 的局限。首先 TCP KeepAlive 监测的方式是发送一个 probe 包，会给网络带来额外的流量，另外 TCP KeepAlive 只能在内核层级监测连接的存活与否，而连接的存活不一定代表服务的可用。例如当一个服务器 CPU 进程服务器占用达到 100%，已经卡死不能响应请求了，此时 TCP KeepAlive 依然会认为连接是存活的。因此 TCP KeepAlive 对于应用层程序的价值是相对较小的。需要做连接保活的应用层程序，例如 QQ，往往会在应用层实现自己的心跳功能。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/TCP-Protocol/a15b4afegy1fmviz5449mj21hc0u01kx.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;tcp-的特性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#tcp-的特性&quot;&gt;&lt;/a&gt; TCP 的特性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;TCP 提供一种面向连接的、可靠的字节流服务&lt;/li&gt;
&lt;li&gt;在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP&lt;/li&gt;
&lt;li&gt;TCP 使用校验和，确认和重传机制来保证可靠传输&lt;/li&gt;
&lt;li&gt;TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复&lt;/li&gt;
&lt;li&gt;TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。&lt;/p&gt;</summary>
    
    
    
    
    <category term="TCP" scheme="https://mikado.drrr.app/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化介绍</title>
    <link href="https://mikado.drrr.app/Redis-Persistence/"/>
    <id>https://mikado.drrr.app/Redis-Persistence/</id>
    <published>2019-02-21T09:59:51.000Z</published>
    <updated>2020-09-22T10:11:38.947Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="/images/Redis-Persistence/a15b4afegy1fmvjboz2dgj21hc0u0qj6.jpg" alt="" /></p><blockquote><p>EN：<a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a> <br>CN：<a href="http://www.redis.cn/topics/persistence.html">http://www.redis.cn/topics/persistence.html</a></p></blockquote><h3 id="redis-提供了不同级别的持久化方式"><a class="markdownIt-Anchor" href="#redis-提供了不同级别的持久化方式"></a> Redis 提供了不同级别的持久化方式:</h3><p><code>RDB</code> 持久化方式能够在指定的时间间隔能对你的数据进行快照存储.</p><ul><li><code>AOF</code> 持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据, <code>AOF</code> 命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对 <code>AOF</code> 文件进行后台重写,使得 <code>AOF</code> 文件的体积不至于过大.</li><li>如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</li><li>你也可以同时开启两种持久化方式, 在这种情况下, 当Redis重启的时候会优先载入 <code>AOF</code> 文件来恢复原始的数据,因为在通常情况下 <code>AOF</code> 文件保存的数据集要比 <code>RDB</code> 文件保存的数据集要完整.</li><li>最重要的事情是了解 <code>RDB</code> 和 <code>AOF</code> 持久化方式的不同,让我们以 <code>RDB</code> 持久化方式开始：<a id="more"></a></li></ul><h3 id="rdb优点"><a class="markdownIt-Anchor" href="#rdb优点"></a> <code>RDB</code>优点</h3><ul><li><code>RDB</code> 持久化保存一个时间点的Redis数据</li><li><code>RDB</code> 适合容灾恢复</li><li><code>RDB</code> 最大限度地提高了Redis的性能</li><li>与 <code>AOF</code> 相比， <code>RDB</code> 允许使用大数据集更快地重启。</li></ul><h3 id="rdb缺点"><a class="markdownIt-Anchor" href="#rdb缺点"></a> <code>RDB</code>缺点</h3><ul><li>意外情况发生，数据会有丢失</li><li><code>RDB</code> 需要<code>fork()</code>出子进程来处理持久化，如果数据集比较大，<code>fork()</code>会很耗时的。再加上CPU性能也不是很好，耗时就会很久。 <code>AOF</code> 也是需要<code>fork()</code>的，但是 <code>AOF</code> 能调整重写无需权衡持久性的日志的频率</li></ul><h3 id="aof-优点"><a class="markdownIt-Anchor" href="#aof-优点"></a> <code>AOF</code> 优点</h3><ul><li><code>AOF</code> 有多种<code>fsync</code>策略（NO <code>fsync</code>,每秒<code>fsync</code>，每个查询<code>fsync</code>）。默认的每秒<code>fsync</code>策略，写性能也是不错的（<code>fsync</code>是使用后台线程执行的，当没有<code>fsync</code>正在进行时主线程会尽力执行写操作）</li><li><code>AOF</code> 的日志的append的，所以发生意外时，使用<code>redis-check-aof</code> 工具还是能简单的修复</li><li>当Redis太大时，Redis会在后台自动重写 <code>AOF</code> 日志。重写是完全安全的，因为当Redis继续附加到旧文件时，使用创建当前数据集所需的最小操作集生成一个全新的文件，并一旦第二个文件准备就绪，Redis会切换两个并开始附加到 新的那一个。</li><li><code>AOF</code> 包含所有便于理解格式的操作日志，你可以轻松导入一个 <code>AOF</code> 文件。万一使用了<code>FLUSHALL</code>，还是能通过 <code>AOF</code> 文件恢复的。</li></ul><h3 id="aof-缺点"><a class="markdownIt-Anchor" href="#aof-缺点"></a> <code>AOF</code> 缺点</h3><ul><li>文件比 <code>RDB</code> 大</li><li>精确<code>fsync</code>策略的话，<code>AOF</code> 比较慢。禁用<code>fsync</code>的话，跟 <code>RDB</code> 差不多快</li></ul><h3 id="快照snapshotting"><a class="markdownIt-Anchor" href="#快照snapshotting"></a> 快照（Snapshotting）</h3><p>默认的数据集快照是保存到磁盘的，一个叫 <code>dump.rdb</code>  的二进制文件。你可以配置在N秒内至少M次修改时保存快照。有两个命令 <code>SAVE</code> 和<code>BGSAVE</code>。例子，60秒内有1000key改动：<code>save 60 1000</code></p><h3 id="快照是怎么工作的how-it-works"><a class="markdownIt-Anchor" href="#快照是怎么工作的how-it-works"></a> 快照是怎么工作的（How it works)</h3><ul><li>Redis执行<code>fork</code>操作，现在有一个子进程和一个父进程。</li><li>子进程开始把数据集写入临时的 <code>RDB</code> 文件</li><li>当子进程完成写入新的 <code>RDB</code> 文件，就会替换掉旧的文件</li></ul><h3 id="附加文件append-only-file"><a class="markdownIt-Anchor" href="#附加文件append-only-file"></a> 附加文件（Append-only file）</h3><p>快照不是非常耐用（durable）。如果发生意外（Redis停止，断电，<code>kill -9</code>），最后的Redis数据就会丢失。在1.1版本后，你可以在配置文件中开启 <code>AOF</code> ：<code>appendonly file</code>。现在开始，每次Redis接收到命令将会附加到 <code>AOF</code> 中。当Redis重启时，Redis会自己根据 <code>AOF</code> 文件重建状态。</p><h3 id="日记重写log-rewriting"><a class="markdownIt-Anchor" href="#日记重写log-rewriting"></a> 日记重写（Log rewriting）</h3><p><code>AOF</code> 会根据执行越来越大。例如，如果将一个计数器递增100次，则最终会在数据集中包含一个包含最终值的key，但在 <code>AOF</code> 中会有100个条目。重建当前状态其实不需要其中99个条目。在Redis 2.2中有 <code>BGREWRITEAOF</code>  这个命令，这个会分析出重建当前数据集所需最短的命令。在Redis 2.4之后就会自动执行（更多信息需要看配置文件）。</p><h3 id="aof-的持久性如何how-durable-is-the-append-only-file"><a class="markdownIt-Anchor" href="#aof-的持久性如何how-durable-is-the-append-only-file"></a> <code>AOF</code> 的持久性如何？（How durable is the append only file?)</h3><p><code>AOF</code> 有三种配置来配置备份频率</p><ul><li>每个命令都<code>fsync</code>备份。非常非常慢，但是非常安全。</li><li>每秒<code>fsync</code>备份。如果发送意外，最多也就丢失1s的数据</li><li>不<code>fsync</code>备份。<br /><code>AOF</code> 默认是第二个(每秒<code>fsync</code>备份)。</li></ul><h3 id="如果-aof-文件损坏怎么处理"><a class="markdownIt-Anchor" href="#如果-aof-文件损坏怎么处理"></a> 如果 <code>AOF</code> 文件损坏怎么处理</h3><ul><li>备份你的 <code>AOF</code> 文件</li><li>使用Redis自带的<code>redis-check-aof</code>工具。 <code>$ redis-check-aof --fix</code></li><li>(可选)使用 <code>diff -u</code> 来查看两个文件的不同</li><li>使用修复后的文件重启Redis服务服务器</li></ul><h3 id="怎么修复的"><a class="markdownIt-Anchor" href="#怎么修复的"></a> 怎么修复的？</h3><ul><li>Redis执行<code>fork</code>操作，现在有一个子进程和一个父进程。</li><li>子进程开始写新的 <code>AOF</code> 到临时文件</li><li>父进程把所有新的改动缓存到内存缓冲区（in-memory buffer）（同时也会把新的改动append到旧的 <code>AOF</code> 文件）。</li><li>当子进程完成后，父进程得到一个信号，开始将内存缓冲区的数据append到新的 <code>AOF</code> 文件中</li><li>Redis会进行原子性的重命名，将临时文件重命名为新的。并开始appending旧的数据。</li></ul><h3 id="怎么从-rdb-切换到-aof"><a class="markdownIt-Anchor" href="#怎么从-rdb-切换到-aof"></a> 怎么从 <code>RDB</code> 切换到 <code>AOF</code></h3><p>在Redis 2.2之后有不同的操作方式</p><p><em>Redis &gt;= 2.2</em></p><ul><li>备份最新的<code>dump.rdb</code>文件，并移动到安全的地方。</li><li>发送两个命令 <code>redis-cli config set appendonly yes</code> 和 <code>redis-cli config set save &quot;&quot;</code>。</li><li>确保写命令会被正确地追加到  <code>AOF</code>  文件的末尾。</li><li>执行的第一条命令开启了 <code>AOF</code> 功能： Redis 会阻塞直到初始 <code>AOF</code> 文件创建完成为止， 之后 Redis 会继续处理命令请求， 并开始将写入命令追加到 <code>AOF</code>  文件末尾。</li></ul><p>执行的第二条命令用于关闭 <code>RDB</code> 功能。 这一步是可选的， 如果你愿意的话， 也可以同时使用 <code>RDB</code> 和 <code>AOF</code> 这两种持久化功能。</p><p><strong>重要</strong>:别忘了在 <code>redis.conf</code> 中打开 <code>AOF</code> 功能！ 否则的话， 服务器重启之后， 之前通过 <code>CONFIG SET</code> 设置的配置就会被失效，程序会按原来的配置来启动服务器</p><p><em>Redis 2.0</em></p><ul><li>备份最新的<code>dump.rdb</code> 文件，并移动到安全的地方</li><li>停止写入。</li><li>执行 <code>redis-cli bgrewriteaof</code>， 这个会创建 <code>AOF</code> 文件。</li><li>生成完 <code>AOF</code> 文件就停止Redis服务器。</li><li><code>redis.conf</code>中开启 <code>AOF</code> 持久化。</li><li>重启Redis服务器。</li><li>确保您的数据库包含相同数量的Key。</li><li>确保写入正确附加到 <code>AOF</code> 文件。</li></ul><h3 id="aof-和-rdb-之间的相互作用"><a class="markdownIt-Anchor" href="#aof-和-rdb-之间的相互作用"></a> <code>AOF</code> 和 <code>RDB</code> 之间的相互作用</h3><p>在版本号大于等于 2.4 的 Redis 中，<code>BGSAVE</code> 执行的过程中，不可以执行 <code>BGREWRITEAOF</code> 。反过来说，在 <code>BGREWRITEAOF</code> 执行的过程中， 也不可以执行 <code>BGSAVE</code>。这可以防止两个 Redis 后台进程同时对磁盘进行大量的 I/O 操作。</p><p>如果 <code>BGSAVE</code> 正在执行， 并且用户显示地调用 <code>BGREWRITEAOF</code> 命令， 那么服务器将向用户回复一个 OK 状态， 并告知用户，<code>BGREWRITEAOF</code> 已经被预定执行： 一旦 <code>BGSAVE</code> 执行完毕，<code>BGREWRITEAOF</code> 就会正式开始。 当 Redis 启动时， 如果 <code>RDB</code> 持久化和 <code>AOF</code> 持久化都被打开了， 那么程序会优先使用  <code>AOF</code> 文件来恢复数据集， 因为 <code>AOF</code> 文件所保存的数据通常是最完整的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/Redis-Persistence/a15b4afegy1fmvjboz2dgj21hc0u0qj6.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;EN：&lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;https://redis.io/topics/persistence&lt;/a&gt; &lt;br&gt;CN：&lt;a href=&quot;http://www.redis.cn/topics/persistence.html&quot;&gt;http://www.redis.cn/topics/persistence.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;redis-提供了不同级别的持久化方式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#redis-提供了不同级别的持久化方式&quot;&gt;&lt;/a&gt; Redis 提供了不同级别的持久化方式:&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;RDB&lt;/code&gt; 持久化方式能够在指定的时间间隔能对你的数据进行快照存储.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AOF&lt;/code&gt; 持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据, &lt;code&gt;AOF&lt;/code&gt; 命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对 &lt;code&gt;AOF&lt;/code&gt; 文件进行后台重写,使得 &lt;code&gt;AOF&lt;/code&gt; 文件的体积不至于过大.&lt;/li&gt;
&lt;li&gt;如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.&lt;/li&gt;
&lt;li&gt;你也可以同时开启两种持久化方式, 在这种情况下, 当Redis重启的时候会优先载入 &lt;code&gt;AOF&lt;/code&gt; 文件来恢复原始的数据,因为在通常情况下 &lt;code&gt;AOF&lt;/code&gt; 文件保存的数据集要比 &lt;code&gt;RDB&lt;/code&gt; 文件保存的数据集要完整.&lt;/li&gt;
&lt;li&gt;最重要的事情是了解 &lt;code&gt;RDB&lt;/code&gt; 和 &lt;code&gt;AOF&lt;/code&gt; 持久化方式的不同,让我们以 &lt;code&gt;RDB&lt;/code&gt; 持久化方式开始：</summary>
    
    
    
    
    <category term="Linux" scheme="https://mikado.drrr.app/tags/Linux/"/>
    
    <category term="Redis" scheme="https://mikado.drrr.app/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu服务器安装</title>
    <link href="https://mikado.drrr.app/Ubuntu-Server-Install-Note/"/>
    <id>https://mikado.drrr.app/Ubuntu-Server-Install-Note/</id>
    <published>2019-01-31T02:07:09.000Z</published>
    <updated>2020-09-22T10:11:38.947Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="/images/Ubuntu-Server-Install-Note/0072Vf1pgy1foxk73gascj31hc0u07e1.jpg" alt="" /></p><p>This is a note when I installing Ubuntu 18.04 LTS Server.</p><h2 id="before-install"><a class="markdownIt-Anchor" href="#before-install"></a> Before install</h2><h3 id="change-ssh-port"><a class="markdownIt-Anchor" href="#change-ssh-port"></a> Change SSH port</h3><ol><li>Edit ssh config</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><ol start="2"><li>Change port</li><li>Restart sshd service</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="add-user"><a class="markdownIt-Anchor" href="#add-user"></a> Add user</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -m -s /bin/bash &#123;username&#125;</span><br></pre></td></tr></table></figure><h3 id="edit-visudo"><a class="markdownIt-Anchor" href="#edit-visudo"></a> Edit visudo</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visudo</span><br></pre></td></tr></table></figure><ul><li>if <code>visudo</code> is using <code>nano</code>, you can use <code>update-alternatives --config editor</code> chage default editor.</li></ul><h3 id="set-up-user-password"><a class="markdownIt-Anchor" href="#set-up-user-password"></a> Set up user password</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd &#123;username&#125;</span><br></pre></td></tr></table></figure><h3 id="change-user"><a class="markdownIt-Anchor" href="#change-user"></a> Change user</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su &#123;username&#125;</span><br></pre></td></tr></table></figure><h3 id="update-sources-mirror"><a class="markdownIt-Anchor" href="#update-sources-mirror"></a> Update sources mirror</h3><blockquote><p><a href="https://mirrors.ustc.edu.cn/help/ubuntu.html">https://mirrors.ustc.edu.cn/help/ubuntu.html</a></p></blockquote><ol><li>Back up sources list</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><ol start="2"><li>Has two way to update sources list.</li></ol><ul><li>If you using English, the <code>&lt;country-code&gt;</code> is empty.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sed -i &#x27;s/&lt;country-code&gt;.archive.ubuntu.com/mirrors.ustc.edu.cn/g&#x27; /etc/apt/sources.list</span><br></pre></td></tr></table></figure><ul><li>Edit <code>/etc/apt/sources.list</code>, need <code>sudo</code>.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 默认注释了源码仓库，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span><span class="bash"> 预发布软件源，不建议启用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure><h3 id="update-system"><a class="markdownIt-Anchor" href="#update-system"></a> Update system</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h2 id="install-develop-tool"><a class="markdownIt-Anchor" href="#install-develop-tool"></a> Install develop tool</h2><p><strong>Not root!!!</strong></p><h3 id="vimrc-config"><a class="markdownIt-Anchor" href="#vimrc-config"></a> Vimrc config</h3><p>edit <code>~/.vimrc</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set number</span><br><span class="line">syntax on</span><br></pre></td></tr></table></figure><h3 id="php-72"><a class="markdownIt-Anchor" href="#php-72"></a> PHP 7.2</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php7.2 php7.2-mysql php7.2-curl \</span><br><span class="line">    php7.2-common php7.2-xml php7.2-json \</span><br><span class="line">    php7.2-cli php7.2-bcmath php7.2-fpm \</span><br><span class="line">    php7.2-mbstring</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="composer"><a class="markdownIt-Anchor" href="#composer"></a> Composer</h3><ul><li>Install composer</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">php -r &quot;copy(&#x27;https://getcomposer.org/installer&#x27;, &#x27;composer-setup.php&#x27;);&quot;</span><br><span class="line">php -r &quot;if (hash_file(&#x27;sha384&#x27;, &#x27;composer-setup.php&#x27;) === &#x27;93b54496392c062774670ac18b134c3b3a95e5a5e5c8f1a9f115f203b75bf9a129d5daa8ba6a13e2cc8a1da0806388a8&#x27;) &#123; echo &#x27;Installer verified&#x27;; &#125; else &#123; echo &#x27;Installer corrupt&#x27;; unlink(&#x27;composer-setup.php&#x27;);&#125; echo PHP_EOL;&quot;</span><br><span class="line">php composer-setup.php</span><br><span class="line">php -r &quot;unlink(&#x27;composer-setup.php&#x27;);&quot;</span><br><span class="line">sudo cp composer.phar /user/bin/composer</span><br></pre></td></tr></table></figure><ul><li>Set up composer packagist url</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config -g repo.packagist composer https://packagist.laravel-china.org</span><br></pre></td></tr></table></figure><h3 id="mariadb-104"><a class="markdownIt-Anchor" href="#mariadb-104"></a> MariaDB-10.4</h3><h4 id="install-mariadb-server"><a class="markdownIt-Anchor" href="#install-mariadb-server"></a> Install mariadb server</h4><blockquote><p><a href="https://downloads.mariadb.org/mariadb/repositories">https://downloads.mariadb.org/mariadb/repositories</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install software-properties-common</span><br><span class="line">sudo apt-key adv --recv-keys --keyserver hkp://keyserver.ubuntu.com:80 0xF1656F24C74CD1D8</span><br><span class="line">sudo add-apt-repository &#x27;deb [arch=amd64,arm64,ppc64el] https://mirrors.shu.edu.cn/mariadb/repo/10.4/ubuntu bionic main&#x27;</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install mariadb-server</span><br></pre></td></tr></table></figure><h4 id="add-user-2"><a class="markdownIt-Anchor" href="#add-user-2"></a> Add user</h4><blockquote><p><a href="https://mariadb.com/kb/en/library/create-user/">https://mariadb.com/kb/en/library/create-user/</a></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> <span class="keyword">REPLACE</span>] <span class="keyword">USER</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] <span class="string">&#x27;foo2&#x27;</span>@<span class="string">&#x27;test&#x27;</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="grant-user"><a class="markdownIt-Anchor" href="#grant-user"></a> Grant user</h4><blockquote><p><a href="https://mariadb.com/kb/en/library/grant">https://mariadb.com/kb/en/library/grant</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL ON laravel_blog.* TO &#x27;laravel_blog&#x27;@&#x27;%&#x27;</span><br></pre></td></tr></table></figure><h4 id="change-port"><a class="markdownIt-Anchor" href="#change-port"></a> Change port</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/mysql/my.cnf</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/Ubuntu-Server-Install-Note/0072Vf1pgy1foxk73gascj31hc0u07e1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;This is a note when I installing Ubuntu 18.04 LTS Server.&lt;/p&gt;
&lt;h2 id=&quot;before-install&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#before-install&quot;&gt;&lt;/a&gt; Before install&lt;/h2&gt;
&lt;h3 id=&quot;change-ssh-port&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#change-ssh-port&quot;&gt;&lt;/a&gt; Change SSH port&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Edit ssh config&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo vim /etc/ssh/sshd_config&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Change port&lt;/li&gt;
&lt;li&gt;Restart sshd service&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;service sshd restart&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://mikado.drrr.app/tags/Linux/"/>
    
    <category term="Ubuntu" scheme="https://mikado.drrr.app/tags/Ubuntu/"/>
    
    <category term="Linux Server" scheme="https://mikado.drrr.app/tags/Linux-Server/"/>
    
  </entry>
  
  <entry>
    <title>Tmux和Zsh的安装与配置</title>
    <link href="https://mikado.drrr.app/Tmux-And-ZSH-Install-And-Configuration/"/>
    <id>https://mikado.drrr.app/Tmux-And-ZSH-Install-And-Configuration/</id>
    <published>2019-01-27T13:08:54.000Z</published>
    <updated>2020-09-22T10:11:38.947Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="/images/Tmux-And-ZSH-Install-And-Configuration/a15b4afegy1fnokpqcv02j21hc0u0jux.jpg" alt="" /></p><p>记录 Linux (Ubuntu 18.04 LTS) 下装 Tmux 和 Zsh 的过程<a id="more"></a></p><h2 id="安装tmux和zsh"><a class="markdownIt-Anchor" href="#安装tmux和zsh"></a> 安装Tmux和Zsh</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update </span><br><span class="line">sudo apt install tmux zsh</span><br></pre></td></tr></table></figure><h2 id="配置zsh"><a class="markdownIt-Anchor" href="#配置zsh"></a> 配置Zsh</h2><h3 id="安装oh-my-zsh"><a class="markdownIt-Anchor" href="#安装oh-my-zsh"></a> 安装Oh-My-Zsh</h3><blockquote><p>具体内容可以查看<a href="https://ohmyz.sh/">官网</a></p></blockquote><ul><li>使用 <code>curl</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><ul><li>使用 <code>wget</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="安装插件"><a class="markdownIt-Anchor" href="#安装插件"></a> 安装插件</h3><p>使用的插件有 <code>zsh-syntax-highlighting</code>，<code>zsh-autosuggestions</code>，<code>autojump</code> (这个可以使用自带的 <code>z</code> 来替换使用)。主题的话，就基本使用两个，一个是默认的<code>robbyrussell</code>和<code>pure</code>（<a href="https://github.com/sindresorhus/pure">Github地址</a>）</p><h2 id="配置tmux"><a class="markdownIt-Anchor" href="#配置tmux"></a> 配置Tmux</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">set -g default-terminal &quot;screen-256color&quot;</span><br><span class="line"># colors</span><br><span class="line">set -g status-bg black</span><br><span class="line">set -g status-fg white</span><br><span class="line"></span><br><span class="line"># mouse</span><br><span class="line">set -g mouse on</span><br><span class="line"></span><br><span class="line"># shell</span><br><span class="line">set -g default-shell &quot;&#x2F;usr&#x2F;bin&#x2F;zsh&quot;</span><br><span class="line"></span><br><span class="line"># status</span><br><span class="line">set -g status-left-length 50</span><br><span class="line"></span><br><span class="line"># prefix key M-a is Alt+a</span><br><span class="line">unbind C-b</span><br><span class="line">set-option -g prefix M-a</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/Tmux-And-ZSH-Install-And-Configuration/a15b4afegy1fnokpqcv02j21hc0u0jux.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;记录 Linux (Ubuntu 18.04 LTS) 下装 Tmux 和 Zsh 的过程</summary>
    
    
    
    
    <category term="Tmux" scheme="https://mikado.drrr.app/tags/Tmux/"/>
    
    <category term="Zsh" scheme="https://mikado.drrr.app/tags/Zsh/"/>
    
    <category term="Linux" scheme="https://mikado.drrr.app/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客</title>
    <link href="https://mikado.drrr.app/First-Blog/"/>
    <id>https://mikado.drrr.app/First-Blog/</id>
    <published>2019-01-26T07:54:21.000Z</published>
    <updated>2020-09-22T10:11:38.947Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="/images/First-Blog/arcipello-cherry_blossoms-clouds-landscape-nobody-original-petals-scenic-tree.jpg" alt="image" /></p><p>最近逛了v2ex，发现了很多有意思的博客，去逛了逛，发现了很多有意思的内容。刚好2019新年之际，就打算给自己立了flag，写博客(逃<a id="more"></a></p><p>希望自己能坚持下去</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/First-Blog/arcipello-cherry_blossoms-clouds-landscape-nobody-original-petals-scenic-tree.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;最近逛了v2ex，发现了很多有意思的博客，去逛了逛，发现了很多有意思的内容。刚好2019新年之际，就打算给自己立了flag，写博客(逃</summary>
    
    
    
    
  </entry>
  
</feed>
